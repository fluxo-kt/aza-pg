# ============================================================================
# Build PostgreSQL Image - Manual Development Workflow
# ============================================================================
#
# PURPOSE:
# --------
# This workflow is for developers and QA to manually test PostgreSQL image
# builds with different extension versions BEFORE releasing to production.
#
# WHO SHOULD USE THIS:
# -------------------
# - Developers: Testing extension version combinations
# - QA/Validation: Multi-platform compatibility checks (amd64 + arm64)
# - Pre-release validation before merging to 'release' branch
#
# WHEN TO USE THIS:
# ----------------
# MANUAL TRIGGER (GitHub UI or gh CLI):
#   1. You want to test a custom combination of extension versions
#   2. You're validating arm64 compatibility (native ARM64 runners)
#   3. You're verifying a new extension or extension version works
#   4. Before creating a PR/release candidate that should be published
#
# DO NOT USE THIS FOR:
# -------------------
# - Automatic CI on commits (use ci.yml for fast validation)
# - Production releases (use publish.yml when pushing to 'release' branch)
# - Simple validation (use local 'bun run build' or 'bun run validate')
#
# WHAT IT DOES:
# -----------
# 1. Lint & Validate: Fast syntax checks, manifest validation, smoke tests
# 2. Build: Single or multi-platform based on push_image input
#    - push_image=false: Single-platform amd64, local load (no push)
#    - push_image=true: Multi-platform (amd64 + arm64 native), push to registry
# 3. Test: Extension loading, auto-config, primary/replica/single stacks
# 4. Scan: Trivy security vulnerability scan
# 5. Output: Full test report, image digest, SHA hashes
#
# BUILD METHOD:
# ------------
# When push_image=true:
#   - Native builds on platform-specific runners (no QEMU emulation)
#   - amd64: ubuntu-latest (x86_64)
#   - arm64: ubuntu-24.04-arm (ARM64 native)
#   - Builds run in parallel for faster execution
#   - Each platform pushes by digest
#   - Final manifest combines both architectures
#
# When push_image=false:
#   - Single-platform amd64 build
#   - No push to registry (local load only)
#   - Fast iteration for local testing
#
# HOW TO TRIGGER:
# ---------------
# GitHub UI:
#   Actions tab â†’ "Build PostgreSQL Image" â†’ "Run workflow"
#   Choose branch and optional version inputs
#
# GitHub CLI:
#   gh workflow run build-postgres-image.yml -r main
#   gh workflow run build-postgres-image.yml -r main \
#     -f pg_version=18 \
#     -f pgvector_version=0.8.1 \
#     -f pg_cron_version=1.6.7 \
#     -f pgaudit_version=18.0 \
#     -f push_image=true
#
# OUTPUTS:
# --------
# - Built image (local by default, push optional via 'push_image' input)
# - Dev-prefixed tags if pushed (e.g., dev-main, dev-main-abc123)
# - Full SBOM and provenance (only when pushed)
# - Test results in GitHub Actions UI
# - Step summary with extension catalog, versions, test status
#
# DIFFERENCES FROM OTHER WORKFLOWS:
# --------------------------------
# vs ci.yml:     No Docker build (ci.yml only validates code/configs)
# vs publish.yml: Manual trigger (publish.yml auto-runs on 'release' branch)
#                 More detailed testing (publish.yml is minimal pre-signature)
#                 Different tagging strategy (build.yml uses dev-prefixed tags)
#                 No push by default (publish.yml always pushes production tags)
#                 No Cosign signing (dev builds only)
#
# TROUBLESHOOTING:
# ---------------
# Failed tests â†’ Check GitHub Actions logs in "Test PostgreSQL Stack" section
# arm64 timeout â†’ Native builds should be fast; check logs for actual error
# Push fails â†’ May need GHCR write permissions or GITHUB_TOKEN with packages scope
# Build fails â†’ Run locally: bun run build or check Dockerfile for syntax
#
# RELATED DOCUMENTATION:
# ----------------------
# - CLAUDE.md - Development standards and fast paths
# - scripts/build.ts - Local build script (Bun TypeScript)
#
# ============================================================================

name: Build PostgreSQL Image

on:
  workflow_dispatch:
    inputs:
      pg_version:
        description: "PostgreSQL version"
        required: false
        default: "18"
      pgvector_version:
        description: "pgvector version"
        required: false
        default: "0.8.1"
      pg_cron_version:
        description: "pg_cron version"
        required: false
        default: "1.6.7"
      pgaudit_version:
        description: "pgAudit version"
        required: false
        default: "18.0"
      push_image:
        description: "Push image to registry (for QA/testing only)"
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  lint:
    name: Lint and Validate
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Bun
        uses: ./.github/actions/setup-bun

      - name: Install dependencies
        run: bun install --frozen-lockfile
        env:
          BUN_CONFIG_INSTALL_MINIMUM_RELEASE_AGE: "86400" # 1 day delay for supply chain security

      - name: Run full validation
        run: bun run validate:full

      - name: Check documentation consistency
        run: bun run check:docs

      - name: Run smoke tests
        run: bun run test:smoke

      - name: Verify manifest sync
        run: bun run verify:generated

  build:
    name: Build PostgreSQL Image (${{ matrix.platform }})
    runs-on: ${{ matrix.runner }}
    needs: lint
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
            artifact: linux-amd64
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
            artifact: linux-arm64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Validate Dockerfile paths
        run: bun scripts/build/validate-dockerfile-paths.ts

      - name: Set up Docker Buildx
        uses: ./.github/actions/setup-buildx

      - name: Log in to GitHub Container Registry
        if: github.event.inputs.push_image == 'true'
        uses: ./.github/actions/ghcr-login
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch,prefix=dev-
            type=sha,prefix=dev-{{branch}}-,format=short
          labels: |
            org.opencontainers.image.title=aza-pg-testing PostgreSQL Development Image
            org.opencontainers.image.description=PostgreSQL 18 with extensions (dev build)
            org.opencontainers.image.vendor=fluxo-kt

      - name: Determine build args
        id: build-args
        run: |
          PG_VERSION="${{ github.event.inputs.pg_version || '18' }}"
          PGVECTOR_VERSION="${{ github.event.inputs.pgvector_version || '0.8.1' }}"
          PG_CRON_VERSION="${{ github.event.inputs.pg_cron_version || '1.6.7' }}"
          PGAUDIT_VERSION="${{ github.event.inputs.pgaudit_version || '18.0' }}"
          echo "pg_version=${PG_VERSION}" >> $GITHUB_OUTPUT
          echo "pgvector_version=${PGVECTOR_VERSION}" >> $GITHUB_OUTPUT
          echo "pg_cron_version=${PG_CRON_VERSION}" >> $GITHUB_OUTPUT
          echo "pgaudit_version=${PGAUDIT_VERSION}" >> $GITHUB_OUTPUT

      - name: Generate cache key
        id: cache-key
        run: |
          CONTENT_HASH="${{ hashFiles('docker/**', 'scripts/extensions/**', 'bun.lock', 'package.json') }}"
          CACHE_KEY="build-cache-${{ github.ref_name }}-${CONTENT_HASH}-${{ matrix.artifact }}"
          echo "key=${CACHE_KEY}" >> $GITHUB_OUTPUT
          echo "content_hash=${CONTENT_HASH}" >> $GITHUB_OUTPUT
          echo "Generated cache key: ${CACHE_KEY}"

      - name: Build and push by digest (multi-platform)
        id: build
        if: github.event.inputs.push_image == 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/postgres/Dockerfile
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push-by-digest=true,name-canonical=true,push=true,oci-mediatypes=true
          build-args: |
            PG_VERSION=${{ steps.build-args.outputs.pg_version }}
            PGCRON_VERSION=${{ steps.build-args.outputs.pg_cron_version }}-2.pgdg13+1
            PGAUDIT_VERSION=${{ steps.build-args.outputs.pgaudit_version }}-2.pgdg13+1
            PGVECTOR_VERSION=${{ steps.build-args.outputs.pgvector_version }}-2.pgdg13+1
          cache-from: type=gha,scope=${{ github.ref_name }}-${{ matrix.artifact }}
          cache-to: type=gha,mode=max,scope=${{ github.ref_name }}-${{ matrix.artifact }}
          # Enable OCI media types explicitly for proper multi-arch manifest support
          provenance: mode=max
          sbom: true

      - name: Build and load (local only)
        id: build-local
        if: github.event.inputs.push_image != 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/postgres/Dockerfile
          platforms: ${{ matrix.platform }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          load: true
          build-args: |
            PG_VERSION=${{ steps.build-args.outputs.pg_version }}
            PGCRON_VERSION=${{ steps.build-args.outputs.pg_cron_version }}-2.pgdg13+1
            PGAUDIT_VERSION=${{ steps.build-args.outputs.pgaudit_version }}-2.pgdg13+1
            PGVECTOR_VERSION=${{ steps.build-args.outputs.pgvector_version }}-2.pgdg13+1
          cache-from: type=gha,scope=${{ github.ref_name }}-${{ matrix.artifact }}
          cache-to: type=gha,mode=max,scope=${{ github.ref_name }}-${{ matrix.artifact }}
          provenance: false
          sbom: false

      - name: Export digest (multi-platform)
        if: github.event.inputs.push_image == 'true'
        run: |
          mkdir -p ${{ runner.temp }}/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "${{ runner.temp }}/digests/${digest#sha256:}"
          echo "Exported digest: ${digest}"

      - name: Upload digest (multi-platform)
        if: github.event.inputs.push_image == 'true'
        uses: actions/upload-artifact@v5
        with:
          name: digests-${{ matrix.artifact }}
          path: ${{ runner.temp }}/digests/*
          if-no-files-found: error
          retention-days: 1

      - name: Monitor cache usage
        if: always()
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          bun scripts/ci/monitor-cache-usage.ts \
            --repository ${{ github.repository }} \
            --platform "${{ matrix.platform }}" \
            --github-summary

      - name: Output build information (amd64 only)
        if: matrix.platform == 'linux/amd64'
        run: |
          echo "### PostgreSQL Image Built Successfully :rocket:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.push_image }}" == "true" ]; then
            echo "**Build Type:** Multi-platform (amd64 + arm64 native)" >> $GITHUB_STEP_SUMMARY
            echo "**Image Digest (amd64):** \`${{ steps.build.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Build Type:** Local single-platform (amd64)" >> $GITHUB_STEP_SUMMARY
            echo "**Image Digest:** \`${{ steps.build-local.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
          fi
          echo "**PostgreSQL Version:** ${{ steps.build-args.outputs.pg_version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Extensions:**" >> $GITHUB_STEP_SUMMARY
          echo "- 38 total catalog entries (36 enabled, 2 disabled: pgq, supautils)" >> $GITHUB_STEP_SUMMARY
          echo "- 36 enabled: 6 builtin + 25 extensions + 5 tools" >> $GITHUB_STEP_SUMMARY
          echo "  (14 PGDG, 11 compiled extensions)" >> $GITHUB_STEP_SUMMARY
          echo "- 6 baseline auto-created: pg_cron, pg_stat_statements, pg_trgm," >> $GITHUB_STEP_SUMMARY
          echo "  pgaudit, plpgsql, vector" >> $GITHUB_STEP_SUMMARY
          echo "- 4 preloaded: auto_explain, pg_cron, pg_stat_statements, pgaudit" >> $GITHUB_STEP_SUMMARY
          echo "- 30 additional extensions available on-demand via CREATE EXTENSION" >> $GITHUB_STEP_SUMMARY
          echo "- PGDG packages: pgvector, pg_cron, pgaudit, timescaledb, postgis, etc." >> $GITHUB_STEP_SUMMARY
          echo "- Compiled extensions: pg_jsonschema, wrappers, pgsodium, vectorscale, etc." >> $GITHUB_STEP_SUMMARY
          echo "- Versions managed via extensions.manifest.json" >> $GITHUB_STEP_SUMMARY

      - name: Verify local image
        if: github.event.inputs.push_image != 'true' && matrix.platform == 'linux/amd64'
        run: |
          # When loaded locally, image may not include registry prefix
          # Try with registry prefix first, fallback to local tag
          if docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} psql --version 2>/dev/null; then
            echo "âœ… Local image verified (with registry prefix)"
          elif docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'dev-${{ github.ref_name }}$' | head -1 | xargs -I {} docker run --rm {} psql --version; then
            echo "âœ… Local image verified (local tag)"
          else
            echo "âŒ Failed to verify local image"
            exit 1
          fi

  merge:
    name: Create Multi-Platform Manifest
    runs-on: ubuntu-latest
    needs: build
    if: github.event.inputs.push_image == 'true'
    timeout-minutes: 15
    outputs:
      image_digest: ${{ steps.merge.outputs.digest }}

    steps:
      - name: Download digests
        uses: actions/download-artifact@v6
        with:
          pattern: digests-*
          path: ${{ runner.temp }}/digests
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: ./.github/actions/setup-buildx

      - name: Log in to GitHub Container Registry
        uses: ./.github/actions/ghcr-login
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create manifest list and push
        id: merge
        working-directory: ${{ runner.temp }}/digests
        run: |
          # Create dev tags from digests
          docker buildx imagetools create \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}-${{ github.sha }} \
            $(printf '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@sha256:%s ' *)

          # Inspect manifest once and extract both digest and format
          INSPECT_JSON=$(docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} --format '{{json .}}')

          MANIFEST_DIGEST=$(echo "$INSPECT_JSON" | jq -r '.manifest.digest // empty')
          if [ -z "$MANIFEST_DIGEST" ]; then
            echo "âŒ ERROR: Failed to extract manifest digest"
            exit 1
          fi

          echo "digest=${MANIFEST_DIGEST}" >> $GITHUB_OUTPUT
          echo "âœ… Multi-platform manifest created: ${MANIFEST_DIGEST}"

          # Verify manifest format (dev builds - informational only)
          echo ""
          echo "=== Manifest Format Check ==="
          MEDIA_TYPE=$(echo "$INSPECT_JSON" | jq -r '.manifest.mediaType // empty')

          if [ -z "$MEDIA_TYPE" ]; then
            echo "âš ï¸  WARNING: Could not determine manifest media type"
            echo "   Manifest inspection may have failed or returned unexpected format"
          elif [[ "$MEDIA_TYPE" == "application/vnd.oci.image.index.v1+json" ]]; then
            echo "âœ… OCI Image Index v1 format (annotations supported)"
          elif [[ "$MEDIA_TYPE" == "application/vnd.docker.distribution.manifest.list.v2+json" ]]; then
            echo "âš ï¸  Docker manifest list v2 format (annotations NOT supported)"
            echo "   Note: Dev builds may lack OCI annotations - this is informational only"
          else
            echo "âš ï¸  Unexpected manifest format: ${MEDIA_TYPE}"
          fi
          echo ""

      - name: Set up Bun
        uses: ./.github/actions/setup-bun

      - name: Verify image
        run: |
          bun scripts/docker/pull-with-retry.ts \
            --image "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}" \
            --max-retries 3
          docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} psql --version
          echo "âœ… PostgreSQL version verified"

      - name: Output manifest digest
        run: |
          echo "### Multi-Platform Manifest Created :package:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Manifest Digest:** \`${{ steps.merge.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`dev-${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`dev-${{ github.ref_name }}-${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Platforms:**" >> $GITHUB_STEP_SUMMARY
          echo "- linux/amd64 (native build on ubuntu-latest)" >> $GITHUB_STEP_SUMMARY
          echo "- linux/arm64 (native build on ubuntu-24.04-arm)" >> $GITHUB_STEP_SUMMARY

  scan-image:
    name: Scan Image for Vulnerabilities
    runs-on: ubuntu-latest
    needs: build
    if: always() && needs.build.result == 'success'
    timeout-minutes: 15
    permissions:
      contents: read
      security-events: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Log in to GitHub Container Registry
        if: github.event.inputs.push_image == 'true'
        uses: ./.github/actions/ghcr-login
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Bun
        if: github.event.inputs.push_image == 'true'
        uses: ./.github/actions/setup-bun

      - name: Pull built image (pushed)
        if: github.event.inputs.push_image == 'true'
        run: |
          bun scripts/docker/pull-with-retry.ts \
            --image "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}" \
            --max-retries 3
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} aza-pg-testing:scan
          echo "ðŸ“¦ Scanning image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}"

      - name: Use local image (not pushed)
        if: github.event.inputs.push_image != 'true'
        run: |
          echo "ðŸ” Using locally built image for security scan..."
          # When loaded locally, image name may not include registry prefix
          # Try with registry prefix first, fallback to finding local tag
          if docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} aza-pg-testing:scan 2>/dev/null; then
            echo "ðŸ“¦ Tagged image with registry prefix for scanning"
          else
            # Find the locally built image by tag pattern
            LOCAL_IMAGE=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'dev-${{ github.ref_name }}$' | head -1)
            if [ -n "$LOCAL_IMAGE" ]; then
              docker tag "$LOCAL_IMAGE" aza-pg-testing:scan
              echo "ðŸ“¦ Tagged local image $LOCAL_IMAGE for scanning"
            else
              echo "âŒ Could not find locally built image"
              exit 1
            fi
          fi

      - name: Cache Trivy vulnerability database
        uses: actions/cache@v4
        with:
          path: .trivy-cache
          key: trivy-db-${{ runner.os }}-${{ hashFiles('.github/workflows/build-postgres-image.yml') }}
          restore-keys: |
            trivy-db-${{ runner.os }}-

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.33.1
        env:
          TRIVY_CACHE_DIR: .trivy-cache
        with:
          image-ref: "aza-pg-testing:scan"
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH"

      - name: Upload Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        if: always() && hashFiles('trivy-results.sarif') != ''
        with:
          sarif_file: "trivy-results.sarif"

      - name: Run Trivy for console output
        uses: aquasecurity/trivy-action@0.33.1
        env:
          TRIVY_CACHE_DIR: .trivy-cache
        with:
          image-ref: "aza-pg-testing:scan"
          format: "table"
          severity: "CRITICAL,HIGH,MEDIUM"
          exit-code: "1" # Fail build on CRITICAL/HIGH vulnerabilities

      - name: Capture security scan diagnostics on failure
        if: failure()
        run: |
          bun scripts/debug/capture-scan-diagnostics.ts \
            --image "aza-pg-testing:scan" \
            --output-dir "${{ runner.temp }}/scan-diagnostics" \
            --cache-dir .trivy-cache

      - name: Upload security scan failure diagnostics
        if: failure()
        uses: actions/upload-artifact@v5
        with:
          name: scan-failure-diagnostics-${{ github.sha }}
          path: ${{ runner.temp }}/scan-diagnostics/*
          if-no-files-found: warn
          retention-days: 7

      - name: Generate vulnerability summary
        if: always()
        run: |
          echo "### Security Scan Results :shield:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.push_image }}" == "true" ]; then
            DIGEST="${{ needs.merge.outputs.image_digest }}"
          echo "**Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${DIGEST:0:12}\`" >> $GITHUB_STEP_SUMMARY
          else
            TAG="dev-${{ github.ref_name }}"
          echo "**Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}\` (local build)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Severity Filter:** CRITICAL, HIGH" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Scan completed. Check Security tab for details (if pushed)." >> $GITHUB_STEP_SUMMARY

  test:
    name: Test PostgreSQL Stack
    runs-on: ubuntu-latest
    needs: [build, merge]
    if: github.event.inputs.push_image == 'true'
    timeout-minutes: 25

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Bun
        uses: ./.github/actions/setup-bun

      - name: Log in to GitHub Container Registry
        uses: ./.github/actions/ghcr-login
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull built image
        run: |
          bun scripts/docker/pull-with-retry.ts \
            --image "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}" \
            --max-retries 3
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} aza-pg-testing:test

      - name: Test extension loading
        run: |
          echo "ðŸ§ª Testing extension loading..."
          docker run -d --name pg-test \
            -e POSTGRES_PASSWORD=test \
            aza-pg-testing:test

          echo "â³ Waiting for PostgreSQL to start..."
          for i in {1..30}; do
            if docker exec pg-test pg_isready -U postgres > /dev/null 2>&1; then
              echo "âœ… PostgreSQL ready"
              break
            fi
            sleep 2
          done

          docker exec pg-test psql -U postgres -c "CREATE EXTENSION vector;"
          docker exec pg-test psql -U postgres -c "CREATE EXTENSION pg_trgm;"
          docker exec pg-test psql -U postgres -c "CREATE EXTENSION pg_stat_statements;"
          docker exec pg-test psql -U postgres -c "CREATE EXTENSION pg_cron;"
          docker exec pg-test psql -U postgres -c "CREATE EXTENSION pgaudit;"

          echo "ðŸ” Verifying extensions functional..."
          EXT_LIST=$(docker exec pg-test psql -U postgres -tAc \
            "SELECT extname FROM pg_extension \
             WHERE extname IN ('vector', 'pg_trgm', 'pg_stat_statements', \
                               'pg_cron', 'pgaudit') ORDER BY extname;")
          echo "$EXT_LIST" | grep -q "pg_cron" || { echo "âŒ pg_cron not found"; exit 1; }
          echo "$EXT_LIST" | grep -q "pg_stat_statements" || { echo "âŒ pg_stat_statements not found"; exit 1; }
          echo "$EXT_LIST" | grep -q "pg_trgm" || { echo "âŒ pg_trgm not found"; exit 1; }
          echo "$EXT_LIST" | grep -q "pgaudit" || { echo "âŒ pgaudit not found"; exit 1; }
          echo "$EXT_LIST" | grep -q "vector" || { echo "âŒ vector not found"; exit 1; }
          echo "âœ… All 5 extensions installed"

          TRGM_TEST=$(docker exec pg-test psql -U postgres -tAc "SELECT similarity('test', 'test');")
          echo "$TRGM_TEST" | grep -q "1" || { echo "âŒ pg_trgm test failed (expected 1, got: $TRGM_TEST)"; exit 1; }
          echo "âœ… pg_trgm functional"

          VECTOR_TEST=$(docker exec pg-test psql -U postgres -tAc "SELECT '[1,2,3]'::vector;")
          echo "$VECTOR_TEST" | grep -q "\[1,2,3\]" || { echo "âŒ vector test failed (got: $VECTOR_TEST)"; exit 1; }
          echo "âœ… vector functional"

          docker stop pg-test
          docker rm pg-test
          echo "âœ… Extensions test passed!"

      - name: Test auto-config with different memory limits
        run: |
          echo "ðŸ§ª Testing auto-config with 2GB memory limit..."
          docker run -d --name pg-test-2gb \
            -e POSTGRES_PASSWORD=test \
            --memory=2g \
            aza-pg-testing:test

          for i in {1..30}; do
            if docker exec pg-test-2gb pg_isready -U postgres > /dev/null 2>&1; then
              break
            fi
            sleep 2
          done

          echo "Checking auto-config logs for 2GB..."
          docker logs pg-test-2gb 2>&1 | grep -i "detected ram" || true
          docker logs pg-test-2gb 2>&1 | grep -i "shared_buffers" || true

          docker exec pg-test-2gb psql -U postgres -c "SHOW shared_buffers;"
          docker exec pg-test-2gb psql -U postgres -c "SHOW max_connections;"

          docker stop pg-test-2gb
          docker rm pg-test-2gb

          echo "ðŸ§ª Testing auto-config with 4GB memory limit..."
          docker run -d --name pg-test-4gb \
            -e POSTGRES_PASSWORD=test \
            --memory=4g \
            aza-pg-testing:test

          for i in {1..30}; do
            if docker exec pg-test-4gb pg_isready -U postgres > /dev/null 2>&1; then
              break
            fi
            sleep 2
          done

          echo "Checking auto-config logs for 4GB..."
          docker logs pg-test-4gb 2>&1 | grep -i "detected ram" || true
          docker logs pg-test-4gb 2>&1 | grep -i "shared_buffers" || true

          docker exec pg-test-4gb psql -U postgres -c "SHOW shared_buffers;"
          docker exec pg-test-4gb psql -U postgres -c "SHOW max_connections;"

          docker stop pg-test-4gb
          docker rm pg-test-4gb
          echo "âœ… Auto-config test passed!"

      - name: Test all extensions (comprehensive)
        run: |
          echo "ðŸ§ª Testing all 36 enabled extensions comprehensively..."
          docker run -d --name pg-ext-test \
            -e POSTGRES_PASSWORD=test \
            --memory=4g \
            aza-pg-testing:test

          echo "â³ Waiting for PostgreSQL to start..."
          for i in {1..30}; do
            if docker exec pg-ext-test pg_isready -U postgres > /dev/null 2>&1; then
              echo "âœ… PostgreSQL ready"
              break
            fi
            sleep 2
          done

          echo "ðŸ§ª Running comprehensive extension tests..."
          cd scripts/test
          if ! bun run test-all-extensions-functional.ts --container=pg-ext-test; then
            echo "âŒ Extension tests failed"
            docker logs pg-ext-test --tail=100
            docker stop pg-ext-test
            docker rm pg-ext-test
            exit 1
          fi

          docker stop pg-ext-test
          docker rm pg-ext-test
          echo "âœ… All extension tests passed!"

      - name: Deploy and test primary stack
        run: |
          set -euo pipefail  # Exit on any error

          echo "ðŸš€ Deploying primary stack..."
          cd stacks/primary

          # Function for cleanup
          cleanup() {
            echo "Cleaning up..."
            docker compose -f compose.yml -f compose.dev.yml logs --tail=100 || true
            docker compose -f compose.yml -f compose.dev.yml down -v || true
          }
          trap cleanup EXIT ERR  # Cleanup on exit or error

          # Generate test-only credentials (NOT for production)
          TEST_POSTGRES_PASS="test_pg_${GITHUB_RUN_ID}_$(date +%s)"
          TEST_PGBOUNCER_PASS="test_pgb_${GITHUB_RUN_ID}_$(date +%s)"
          TEST_REPLICATION_PASS="test_repl_${GITHUB_RUN_ID}_$(date +%s)"

          # Create .env file
          cat > .env << EOF
          POSTGRES_PASSWORD=${TEST_POSTGRES_PASS}
          PGBOUNCER_AUTH_PASS=${TEST_PGBOUNCER_PASS}
          PG_REPLICATION_PASSWORD=${TEST_REPLICATION_PASS}
          POSTGRES_IMAGE=aza-pg-testing:test
          POSTGRES_MEMORY_LIMIT=2g
          EOF

          # Start stack
          docker compose up -d

          echo "â³ Waiting for services to be healthy..."
          sleep 30

          # Check service health
          docker compose ps

          echo "ðŸ§ª Testing direct PostgreSQL connection..."
          if ! docker compose exec -T postgres psql -U postgres -c "SELECT version();"; then
            echo "âŒ Direct PostgreSQL connection failed"
            touch /tmp/test-failed
            exit 1
          fi

          echo "ðŸ§ª Testing PgBouncer connection..."
          if ! PGPASSWORD=${TEST_PGBOUNCER_PASS} docker compose exec -T pgbouncer \
            psql -h localhost -p 6432 -U pgbouncer_auth -d postgres -c "SHOW POOLS;"; then
            echo "âŒ PgBouncer connection failed"
            touch /tmp/test-failed
            exit 1
          fi

          echo "ðŸ§ª Testing postgres_exporter metrics..."
          if ! docker compose exec -T postgres_exporter wget -q -O - http://localhost:9187/metrics | head -20; then
            echo "âŒ postgres_exporter metrics failed"
            touch /tmp/test-failed
            exit 1
          fi

          echo "ðŸ“Š Stack logs..."
          docker compose logs --tail=50

          echo "âœ… Primary stack test passed!"

      - name: Check test results
        if: always()
        run: |
          if [ -f /tmp/test-failed ]; then
            echo "::error::Primary stack tests failed"
            exit 1
          fi

      - name: Capture PostgreSQL logs on failure
        if: failure()
        run: |
          bun scripts/debug/capture-postgres-diagnostics.ts \
            --container pg-ext-test \
            --output-dir "${{ runner.temp }}/diagnostics"

      - name: Upload test failure diagnostics
        if: failure()
        uses: actions/upload-artifact@v5
        with:
          name: test-failure-diagnostics-${{ github.sha }}
          path: ${{ runner.temp }}/diagnostics/*
          if-no-files-found: warn
          retention-days: 7

    outputs:
      test-status: success

  test-replica-stack:
    name: Test Replica Stack
    runs-on: ubuntu-latest
    needs: [build, merge]
    if: github.event.inputs.push_image == 'true'
    timeout-minutes: 25

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Bun
        uses: ./.github/actions/setup-bun

      - name: Log in to GitHub Container Registry
        uses: ./.github/actions/ghcr-login
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull built image
        run: |
          bun scripts/docker/pull-with-retry.ts \
            --image "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}" \
            --max-retries 3
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} aza-pg-testing:pg18

      - name: Run replica stack tests
        run: |
          set -euo pipefail
          echo "ðŸ§ª Running replica stack tests..."

          cd "$GITHUB_WORKSPACE"
          if ! bun scripts/test/test-replica-stack.ts; then
            echo "âŒ Replica stack tests failed"
            exit 1
          fi

          echo "âœ… Replica stack tests passed!"

      - name: Check test results
        if: always()
        run: |
          if [ -f /tmp/test-failed ]; then
            echo "::error::Replica stack tests failed"
            exit 1
          fi

      - name: Capture replica stack logs on failure
        if: failure()
        run: |
          mkdir -p ${{ runner.temp }}/replica-diagnostics

          echo "=== Capturing Replica Stack Diagnostics ==="
          echo "=== Replica Stack Docker Compose Logs ===" | tee ${{ runner.temp }}/replica-diagnostics/docker-logs.txt
          (cd stacks/replica && docker compose logs --tail=200 2>&1) | tee -a ${{ runner.temp }}/replica-diagnostics/docker-logs.txt || true

          echo "âœ… Replica stack diagnostics captured"

      - name: Upload replica test failure diagnostics
        if: failure()
        uses: actions/upload-artifact@v5
        with:
          name: replica-test-failure-diagnostics-${{ github.sha }}
          path: ${{ runner.temp }}/replica-diagnostics/*
          if-no-files-found: warn
          retention-days: 7

  test-single-stack:
    name: Test Single Stack
    runs-on: ubuntu-latest
    needs: [build, merge]
    if: github.event.inputs.push_image == 'true'
    timeout-minutes: 20

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Bun
        uses: ./.github/actions/setup-bun

      - name: Log in to GitHub Container Registry
        uses: ./.github/actions/ghcr-login
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull built image
        run: |
          bun scripts/docker/pull-with-retry.ts \
            --image "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}" \
            --max-retries 3
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} aza-pg-testing:pg18

      - name: Run single stack tests
        run: |
          set -euo pipefail
          echo "ðŸ§ª Running single stack tests..."

          cd "$GITHUB_WORKSPACE"
          if ! bun scripts/test/test-single-stack.ts; then
            echo "âŒ Single stack tests failed"
            exit 1
          fi

          echo "âœ… Single stack tests passed!"

      - name: Check test results
        if: always()
        run: |
          if [ -f /tmp/test-failed ]; then
            echo "::error::Single stack tests failed"
            exit 1
          fi

      - name: Capture single stack logs on failure
        if: failure()
        run: |
          mkdir -p ${{ runner.temp }}/single-diagnostics

          echo "=== Capturing Single Stack Diagnostics ==="
          echo "=== Single Stack Docker Compose Logs ===" | tee ${{ runner.temp }}/single-diagnostics/docker-logs.txt
          (cd stacks/single && docker compose logs --tail=200 2>&1) | tee -a ${{ runner.temp }}/single-diagnostics/docker-logs.txt || true

          echo "âœ… Single stack diagnostics captured"

      - name: Upload single stack test failure diagnostics
        if: failure()
        uses: actions/upload-artifact@v5
        with:
          name: single-test-failure-diagnostics-${{ github.sha }}
          path: ${{ runner.temp }}/single-diagnostics/*
          if-no-files-found: warn
          retention-days: 7
