# ============================================================================
# Build PostgreSQL Image - Manual Development Workflow
# ============================================================================
#
# PURPOSE:
# --------
# This workflow is for developers and QA to manually test PostgreSQL image
# builds with different extension versions BEFORE releasing to production.
#
# WHO SHOULD USE THIS:
# -------------------
# - Developers: Testing extension version combinations
# - QA/Validation: Multi-platform compatibility checks (amd64 + arm64)
# - Pre-release validation before merging to 'release' branch
#
# WHEN TO USE THIS:
# ----------------
# MANUAL TRIGGER (GitHub UI or gh CLI):
#   1. You want to test a custom combination of extension versions
#   2. You're validating arm64 compatibility (native ARM64 runners)
#   3. You're verifying a new extension or extension version works
#   4. Before creating a PR/release candidate that should be published
#
# DO NOT USE THIS FOR:
# -------------------
# - Automatic CI on commits (use ci.yml for fast validation)
# - Production releases (use publish.yml when pushing to 'release' branch)
# - Simple validation (use local 'bun run build' or 'bun run validate')
#
# WHAT IT DOES:
# -----------
# 1. Lint & Validate: Fast syntax checks, manifest validation, smoke tests
# 2. Build: Single or multi-platform based on push_image input
#    - push_image=false: Single-platform amd64, local load (no push)
#    - push_image=true: Multi-platform (amd64 + arm64 native), push to registry
# 3. Test: Extension loading, auto-config, primary/replica/single stacks
# 4. Scan: Trivy security vulnerability scan
# 5. Output: Full test report, image digest, SHA hashes
#
# BUILD METHOD:
# ------------
# When push_image=true:
#   - Native builds on platform-specific runners (no QEMU emulation)
#   - amd64: ubuntu-latest (x86_64)
#   - arm64: ubuntu-24.04-arm (ARM64 native)
#   - Builds run in parallel for faster execution
#   - Each platform pushes by digest
#   - Final manifest combines both architectures
#
# When push_image=false:
#   - Single-platform amd64 build
#   - No push to registry (local load only)
#   - Fast iteration for local testing
#
# HOW TO TRIGGER:
# ---------------
# GitHub UI:
#   Actions tab ‚Üí "Build PostgreSQL Image" ‚Üí "Run workflow"
#   Choose branch and optional version inputs
#
# GitHub CLI:
#   gh workflow run build-postgres-image.yml -r main
#   gh workflow run build-postgres-image.yml -r main \
#     -f pg_version=18 \
#     -f pgvector_version=0.8.1 \
#     -f pg_cron_version=1.6.7 \
#     -f pgaudit_version=18.0 \
#     -f push_image=true
#
# OUTPUTS:
# --------
# - Built image (local by default, push optional via 'push_image' input)
# - Dev-prefixed tags if pushed (e.g., dev-main, dev-main-abc123)
# - Full SBOM and provenance (only when pushed)
# - Test results in GitHub Actions UI
# - Step summary with extension catalog, versions, test status
#
# DIFFERENCES FROM OTHER WORKFLOWS:
# --------------------------------
# vs ci.yml:     No Docker build (ci.yml only validates code/configs)
# vs publish.yml: Manual trigger (publish.yml auto-runs on 'release' branch)
#                 More detailed testing (publish.yml is minimal pre-signature)
#                 Different tagging strategy (build.yml uses dev-prefixed tags)
#                 No push by default (publish.yml always pushes production tags)
#                 No Cosign signing (dev builds only)
#
# TROUBLESHOOTING:
# ---------------
# Failed tests ‚Üí Check GitHub Actions logs in "Test PostgreSQL Stack" section
# arm64 timeout ‚Üí Native builds should be fast; check logs for actual error
# Push fails ‚Üí May need GHCR write permissions or GITHUB_TOKEN with packages scope
# Build fails ‚Üí Run locally: bun run build or check Dockerfile for syntax
#
# RELATED DOCUMENTATION:
# ----------------------
# - CLAUDE.md - Development standards and fast paths
# - scripts/build.ts - Local build script (Bun TypeScript)
#
# ============================================================================

name: Build PostgreSQL Image

on:
  workflow_dispatch:
    inputs:
      pg_version:
        description: "PostgreSQL version"
        required: false
        default: "18"
      pgvector_version:
        description: "pgvector version"
        required: false
        default: "0.8.1"
      pg_cron_version:
        description: "pg_cron version"
        required: false
        default: "1.6.7"
      pgaudit_version:
        description: "pgAudit version"
        required: false
        default: "18.0"
      push_image:
        description: "Push image to registry (for QA/testing only)"
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  lint:
    name: Lint and Validate
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Parse Bun version from .tool-versions
        id: bun-version
        run: |
          BUN_VERSION=$(grep '^bun ' .tool-versions | awk '{print $2}' | head -1)
          echo "version=${BUN_VERSION}" >> $GITHUB_OUTPUT

      - name: Set up Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ steps.bun-version.outputs.version }}

      - name: Install dependencies
        run: bun install --frozen-lockfile
        env:
          BUN_CONFIG_INSTALL_MINIMUM_RELEASE_AGE: "86400" # 1 day delay for supply chain security

      - name: Run full validation
        run: bun run validate:full

      - name: Check documentation consistency
        run: bun run check:docs

      - name: Run smoke tests
        run: bun run test:smoke

      - name: Verify manifest sync
        run: |
          bun run generate
          git diff --exit-code docker/postgres/extensions.manifest.json \
            docker/postgres/docker-entrypoint-initdb.d/01-extensions.sql

  build:
    name: Build PostgreSQL Image (${{ matrix.platform }})
    runs-on: ${{ matrix.runner }}
    needs: lint
    timeout-minutes: 60
    # Only run arm64 build when push_image=true, always run amd64
    if: matrix.platform == 'linux/amd64' || github.event.inputs.push_image == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
            artifact: linux-amd64
          # arm64 build - will be skipped by job-level if when push_image=false
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
            artifact: linux-arm64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Validate Dockerfile paths
        run: |
          echo "Validating Dockerfile COPY paths exist in build context..."
          # Check that files referenced in Dockerfile exist
          test -f docker/postgres/extensions.manifest.json || exit 1
          test -f docker/postgres/build-extensions.ts || exit 1
          test -f docker/postgres/docker-auto-config-entrypoint.sh || exit 1
          echo "‚úÖ All Dockerfile COPY paths validated"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
            network=host

      - name: Log in to GitHub Container Registry
        if: github.event.inputs.push_image == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch,prefix=dev-
            type=sha,prefix=dev-{{branch}}-,format=short
          labels: |
            org.opencontainers.image.title=aza-pg PostgreSQL Development Image
            org.opencontainers.image.description=PostgreSQL 18 with extensions (dev build)
            org.opencontainers.image.vendor=fluxo-kt

      - name: Determine build args
        id: build-args
        run: |
          PG_VERSION="${{ github.event.inputs.pg_version || '18' }}"
          PGVECTOR_VERSION="${{ github.event.inputs.pgvector_version || '0.8.1' }}"
          PG_CRON_VERSION="${{ github.event.inputs.pg_cron_version || '1.6.7' }}"
          PGAUDIT_VERSION="${{ github.event.inputs.pgaudit_version || '18.0' }}"
          echo "pg_version=${PG_VERSION}" >> $GITHUB_OUTPUT
          echo "pgvector_version=${PGVECTOR_VERSION}" >> $GITHUB_OUTPUT
          echo "pg_cron_version=${PG_CRON_VERSION}" >> $GITHUB_OUTPUT
          echo "pgaudit_version=${PGAUDIT_VERSION}" >> $GITHUB_OUTPUT

      - name: Generate cache key
        id: cache-key
        run: |
          CONTENT_HASH="${{ hashFiles('docker/**', 'scripts/extensions/**', 'bun.lock', 'package.json') }}"
          CACHE_KEY="build-cache-${{ github.ref_name }}-${CONTENT_HASH}-${{ matrix.artifact }}"
          echo "key=${CACHE_KEY}" >> $GITHUB_OUTPUT
          echo "content_hash=${CONTENT_HASH}" >> $GITHUB_OUTPUT
          echo "Generated cache key: ${CACHE_KEY}"

      - name: Build and push by digest (multi-platform)
        id: build
        if: github.event.inputs.push_image == 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/postgres/Dockerfile
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push-by-digest=true,name-canonical=true,push=true
          build-args: |
            PG_VERSION=${{ steps.build-args.outputs.pg_version }}
            PGCRON_VERSION=${{ steps.build-args.outputs.pg_cron_version }}-2.pgdg13+1
            PGAUDIT_VERSION=${{ steps.build-args.outputs.pgaudit_version }}-2.pgdg13+1
            PGVECTOR_VERSION=${{ steps.build-args.outputs.pgvector_version }}-2.pgdg13+1
          cache-from: type=gha,scope=${{ github.ref_name }}-${{ matrix.artifact }}
          cache-to: type=gha,mode=max,scope=${{ github.ref_name }}-${{ matrix.artifact }}
          provenance: mode=max
          sbom: true

      - name: Build and load (local only)
        id: build-local
        if: github.event.inputs.push_image != 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/postgres/Dockerfile
          platforms: ${{ matrix.platform }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          load: true
          build-args: |
            PG_VERSION=${{ steps.build-args.outputs.pg_version }}
            PGCRON_VERSION=${{ steps.build-args.outputs.pg_cron_version }}-2.pgdg13+1
            PGAUDIT_VERSION=${{ steps.build-args.outputs.pgaudit_version }}-2.pgdg13+1
            PGVECTOR_VERSION=${{ steps.build-args.outputs.pgvector_version }}-2.pgdg13+1
          cache-from: type=gha,scope=${{ github.ref_name }}-${{ matrix.artifact }}
          cache-to: type=gha,mode=max,scope=${{ github.ref_name }}-${{ matrix.artifact }}
          provenance: false
          sbom: false

      - name: Export digest (multi-platform)
        if: github.event.inputs.push_image == 'true'
        run: |
          mkdir -p ${{ runner.temp }}/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "${{ runner.temp }}/digests/${digest#sha256:}"
          echo "Exported digest: ${digest}"

      - name: Upload digest (multi-platform)
        if: github.event.inputs.push_image == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ matrix.artifact }}
          path: ${{ runner.temp }}/digests/*
          if-no-files-found: error
          retention-days: 1

      - name: Monitor cache usage
        if: always()
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Checking GitHub Actions cache usage..."

          # Get cache usage from GitHub API
          if CACHE_DATA=$(gh api repos/${{ github.repository }}/actions/cache/usage 2>/dev/null); then
            CACHE_USAGE=$(echo "$CACHE_DATA" | jq -r '.active_caches_size_in_bytes // 0')

            if command -v bc >/dev/null 2>&1; then
              CACHE_GB=$(echo "scale=2; $CACHE_USAGE / 1073741824" | bc)
            else
              # Fallback if bc not available
              CACHE_GB=$(awk "BEGIN {printf \"%.2f\", $CACHE_USAGE / 1073741824}")
            fi

            echo "Current cache usage: ${CACHE_GB}GB"

            # Check if approaching limit
            if command -v bc >/dev/null 2>&1; then
              if (( $(echo "$CACHE_GB > 4" | bc -l) )); then
                echo "‚ö†Ô∏è WARNING: Cache usage approaching GitHub limit (5GB)"
                echo "::warning::Cache usage (${CACHE_GB}GB) approaching GitHub limit"
              fi
            fi

            # Add to step summary
            echo "### Cache Usage (${{ matrix.platform }}): ${CACHE_GB}GB / 5GB" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è Unable to fetch cache usage data from GitHub API"
          fi

      - name: Output build information (amd64 only)
        if: matrix.platform == 'linux/amd64'
        run: |
          echo "### PostgreSQL Image Built Successfully :rocket:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.push_image }}" == "true" ]; then
            echo "**Build Type:** Multi-platform (amd64 + arm64 native)" >> $GITHUB_STEP_SUMMARY
            echo "**Image Digest (amd64):** \`${{ steps.build.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Build Type:** Local single-platform (amd64)" >> $GITHUB_STEP_SUMMARY
            echo "**Image Digest:** \`${{ steps.build-local.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
          fi
          echo "**PostgreSQL Version:** ${{ steps.build-args.outputs.pg_version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Extensions:**" >> $GITHUB_STEP_SUMMARY
          echo "- 38 total catalog entries (36 enabled, 2 disabled: pgq, supautils)" >> $GITHUB_STEP_SUMMARY
          echo "- 36 enabled: 6 builtin + 25 extensions + 5 tools" >> $GITHUB_STEP_SUMMARY
          echo "  (14 PGDG, 11 compiled extensions)" >> $GITHUB_STEP_SUMMARY
          echo "- 6 baseline auto-created: pg_cron, pg_stat_statements, pg_trgm," >> $GITHUB_STEP_SUMMARY
          echo "  pgaudit, plpgsql, vector" >> $GITHUB_STEP_SUMMARY
          echo "- 4 preloaded: auto_explain, pg_cron, pg_stat_statements, pgaudit" >> $GITHUB_STEP_SUMMARY
          echo "- 30 additional extensions available on-demand via CREATE EXTENSION" >> $GITHUB_STEP_SUMMARY
          echo "- PGDG packages: pgvector, pg_cron, pgaudit, timescaledb, postgis, etc." >> $GITHUB_STEP_SUMMARY
          echo "- Compiled extensions: pg_jsonschema, wrappers, pgsodium, vectorscale, etc." >> $GITHUB_STEP_SUMMARY
          echo "- Versions managed via extensions.manifest.json" >> $GITHUB_STEP_SUMMARY

      - name: Verify local image
        if: github.event.inputs.push_image != 'true' && matrix.platform == 'linux/amd64'
        run: |
          # When loaded locally, image may not include registry prefix
          # Try with registry prefix first, fallback to local tag
          if docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} psql --version 2>/dev/null; then
            echo "‚úÖ Local image verified (with registry prefix)"
          elif docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'dev-${{ github.ref_name }}$' | head -1 | xargs -I {} docker run --rm {} psql --version; then
            echo "‚úÖ Local image verified (local tag)"
          else
            echo "‚ùå Failed to verify local image"
            exit 1
          fi

  merge:
    name: Create Multi-Platform Manifest
    runs-on: ubuntu-latest
    needs: build
    if: github.event.inputs.push_image == 'true'
    timeout-minutes: 15
    outputs:
      image_digest: ${{ steps.merge.outputs.digest }}

    steps:
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          pattern: digests-*
          path: ${{ runner.temp }}/digests
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create manifest list and push
        id: merge
        working-directory: ${{ runner.temp }}/digests
        run: |
          # Create dev tags from digests
          docker buildx imagetools create \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}-${{ github.sha }} \
            $(printf '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@sha256:%s ' *)

          # Get the digest of the manifest list
          MANIFEST_DIGEST=$(docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} \
            --format '{{json .}}' | jq -r '.manifest.digest')

          echo "digest=${MANIFEST_DIGEST}" >> $GITHUB_OUTPUT
          echo "‚úÖ Multi-platform manifest created: ${MANIFEST_DIGEST}"

      - name: Verify image
        run: |
          echo "üîç Verifying pushed image..."
          for i in {1..3}; do
            if docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}; then
              echo "‚úÖ Image pulled successfully"
              break
            else
              echo "‚ö†Ô∏è Pull attempt $i failed, retrying in $((i * 5)) seconds..."
              sleep $((i * 5))
              if [ $i -eq 3 ]; then
                echo "‚ùå Failed to pull image after 3 attempts"
                exit 1
              fi
            fi
          done
          docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} psql --version
          echo "‚úÖ Image pulled and PostgreSQL version verified"

      - name: Output manifest digest
        run: |
          echo "### Multi-Platform Manifest Created :package:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Manifest Digest:** \`${{ steps.merge.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`dev-${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`dev-${{ github.ref_name }}-${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Platforms:**" >> $GITHUB_STEP_SUMMARY
          echo "- linux/amd64 (native build on ubuntu-latest)" >> $GITHUB_STEP_SUMMARY
          echo "- linux/arm64 (native build on ubuntu-24.04-arm)" >> $GITHUB_STEP_SUMMARY

  scan-image:
    name: Scan Image for Vulnerabilities
    runs-on: ubuntu-latest
    needs: build
    if: always() && needs.build.result == 'success'
    timeout-minutes: 15
    permissions:
      contents: read
      security-events: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Log in to GitHub Container Registry
        if: github.event.inputs.push_image == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull built image (pushed)
        if: github.event.inputs.push_image == 'true'
        run: |
          echo "üîç Pulling pushed image from registry for security scan..."
          for i in {1..3}; do
            if docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}; then
              echo "‚úÖ Image pulled successfully"
              break
            else
              echo "‚ö†Ô∏è Pull attempt $i failed, retrying in $((i * 5)) seconds..."
              sleep $((i * 5))
              if [ $i -eq 3 ]; then
                echo "‚ùå Failed to pull image after 3 attempts"
                exit 1
              fi
            fi
          done
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} aza-pg:scan
          echo "üì¶ Scanning image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}"

      - name: Use local image (not pushed)
        if: github.event.inputs.push_image != 'true'
        run: |
          echo "üîç Using locally built image for security scan..."
          # When loaded locally, image name may not include registry prefix
          # Try with registry prefix first, fallback to finding local tag
          if docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} aza-pg:scan 2>/dev/null; then
            echo "üì¶ Tagged image with registry prefix for scanning"
          else
            # Find the locally built image by tag pattern
            LOCAL_IMAGE=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'dev-${{ github.ref_name }}$' | head -1)
            if [ -n "$LOCAL_IMAGE" ]; then
              docker tag "$LOCAL_IMAGE" aza-pg:scan
              echo "üì¶ Tagged local image $LOCAL_IMAGE for scanning"
            else
              echo "‚ùå Could not find locally built image"
              exit 1
            fi
          fi

      - name: Cache Trivy vulnerability database
        uses: actions/cache@v4
        with:
          path: .trivy-cache
          key: trivy-db-${{ runner.os }}-${{ hashFiles('.github/workflows/build-postgres-image.yml') }}
          restore-keys: |
            trivy-db-${{ runner.os }}-

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.33.1
        env:
          TRIVY_CACHE_DIR: .trivy-cache
        with:
          image-ref: "aza-pg:scan"
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH"

      - name: Upload Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        if: always() && hashFiles('trivy-results.sarif') != ''
        with:
          sarif_file: "trivy-results.sarif"

      - name: Run Trivy for console output
        uses: aquasecurity/trivy-action@0.33.1
        env:
          TRIVY_CACHE_DIR: .trivy-cache
        with:
          image-ref: "aza-pg:scan"
          format: "table"
          severity: "CRITICAL,HIGH,MEDIUM"
          exit-code: "1" # Fail build on CRITICAL/HIGH vulnerabilities

      - name: Generate vulnerability summary
        if: always()
        run: |
          echo "### Security Scan Results :shield:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.push_image }}" == "true" ]; then
            DIGEST="${{ needs.merge.outputs.image_digest }}"
          echo "**Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${DIGEST:0:12}\`" >> $GITHUB_STEP_SUMMARY
          else
            TAG="dev-${{ github.ref_name }}"
          echo "**Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}\` (local build)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Severity Filter:** CRITICAL, HIGH" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Scan completed. Check Security tab for details (if pushed)." >> $GITHUB_STEP_SUMMARY

  test:
    name: Test PostgreSQL Stack
    runs-on: ubuntu-latest
    needs: [build, merge]
    if: github.event.inputs.push_image == 'true'
    timeout-minutes: 25

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Parse Bun version from .tool-versions
        id: bun-version
        run: |
          BUN_VERSION=$(grep '^bun ' .tool-versions | awk '{print $2}' | head -1)
          echo "version=${BUN_VERSION}" >> $GITHUB_OUTPUT

      - name: Set up Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ steps.bun-version.outputs.version }}

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull built image
        run: |
          echo "üì¶ Pulling image for testing..."
          for i in {1..3}; do
            if docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}; then
              echo "‚úÖ Image pulled successfully"
              break
            else
              echo "‚ö†Ô∏è Pull attempt $i failed, retrying in $((i * 5)) seconds..."
              sleep $((i * 5))
              if [ $i -eq 3 ]; then
                echo "‚ùå Failed to pull image after 3 attempts"
                exit 1
              fi
            fi
          done
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} aza-pg:test

      - name: Test extension loading
        run: |
          echo "üß™ Testing extension loading..."
          docker run -d --name pg-test \
            -e POSTGRES_PASSWORD=test \
            aza-pg:test

          echo "‚è≥ Waiting for PostgreSQL to start..."
          for i in {1..30}; do
            if docker exec pg-test pg_isready -U postgres > /dev/null 2>&1; then
              echo "‚úÖ PostgreSQL ready"
              break
            fi
            sleep 2
          done

          docker exec pg-test psql -U postgres -c "CREATE EXTENSION vector;"
          docker exec pg-test psql -U postgres -c "CREATE EXTENSION pg_trgm;"
          docker exec pg-test psql -U postgres -c "CREATE EXTENSION pg_stat_statements;"
          docker exec pg-test psql -U postgres -c "CREATE EXTENSION pg_cron;"
          docker exec pg-test psql -U postgres -c "CREATE EXTENSION pgaudit;"

          echo "üîç Verifying extensions functional..."
          EXT_LIST=$(docker exec pg-test psql -U postgres -tAc \
            "SELECT extname FROM pg_extension \
             WHERE extname IN ('vector', 'pg_trgm', 'pg_stat_statements', \
                               'pg_cron', 'pgaudit') ORDER BY extname;")
          echo "$EXT_LIST" | grep -q "pg_cron" || { echo "‚ùå pg_cron not found"; exit 1; }
          echo "$EXT_LIST" | grep -q "pg_stat_statements" || { echo "‚ùå pg_stat_statements not found"; exit 1; }
          echo "$EXT_LIST" | grep -q "pg_trgm" || { echo "‚ùå pg_trgm not found"; exit 1; }
          echo "$EXT_LIST" | grep -q "pgaudit" || { echo "‚ùå pgaudit not found"; exit 1; }
          echo "$EXT_LIST" | grep -q "vector" || { echo "‚ùå vector not found"; exit 1; }
          echo "‚úÖ All 5 extensions installed"

          TRGM_TEST=$(docker exec pg-test psql -U postgres -tAc "SELECT similarity('test', 'test');")
          echo "$TRGM_TEST" | grep -q "1" || { echo "‚ùå pg_trgm test failed (expected 1, got: $TRGM_TEST)"; exit 1; }
          echo "‚úÖ pg_trgm functional"

          VECTOR_TEST=$(docker exec pg-test psql -U postgres -tAc "SELECT '[1,2,3]'::vector;")
          echo "$VECTOR_TEST" | grep -q "\[1,2,3\]" || { echo "‚ùå vector test failed (got: $VECTOR_TEST)"; exit 1; }
          echo "‚úÖ vector functional"

          docker stop pg-test
          docker rm pg-test
          echo "‚úÖ Extensions test passed!"

      - name: Test auto-config with different memory limits
        run: |
          echo "üß™ Testing auto-config with 2GB memory limit..."
          docker run -d --name pg-test-2gb \
            -e POSTGRES_PASSWORD=test \
            --memory=2g \
            aza-pg:test

          for i in {1..30}; do
            if docker exec pg-test-2gb pg_isready -U postgres > /dev/null 2>&1; then
              break
            fi
            sleep 2
          done

          echo "Checking auto-config logs for 2GB..."
          docker logs pg-test-2gb 2>&1 | grep -i "detected ram" || true
          docker logs pg-test-2gb 2>&1 | grep -i "shared_buffers" || true

          docker exec pg-test-2gb psql -U postgres -c "SHOW shared_buffers;"
          docker exec pg-test-2gb psql -U postgres -c "SHOW max_connections;"

          docker stop pg-test-2gb
          docker rm pg-test-2gb

          echo "üß™ Testing auto-config with 4GB memory limit..."
          docker run -d --name pg-test-4gb \
            -e POSTGRES_PASSWORD=test \
            --memory=4g \
            aza-pg:test

          for i in {1..30}; do
            if docker exec pg-test-4gb pg_isready -U postgres > /dev/null 2>&1; then
              break
            fi
            sleep 2
          done

          echo "Checking auto-config logs for 4GB..."
          docker logs pg-test-4gb 2>&1 | grep -i "detected ram" || true
          docker logs pg-test-4gb 2>&1 | grep -i "shared_buffers" || true

          docker exec pg-test-4gb psql -U postgres -c "SHOW shared_buffers;"
          docker exec pg-test-4gb psql -U postgres -c "SHOW max_connections;"

          docker stop pg-test-4gb
          docker rm pg-test-4gb
          echo "‚úÖ Auto-config test passed!"

      - name: Test all extensions (comprehensive)
        run: |
          echo "üß™ Testing all 36 enabled extensions comprehensively..."
          docker run -d --name pg-ext-test \
            -e POSTGRES_PASSWORD=test \
            --memory=4g \
            aza-pg:test

          echo "‚è≥ Waiting for PostgreSQL to start..."
          for i in {1..30}; do
            if docker exec pg-ext-test pg_isready -U postgres > /dev/null 2>&1; then
              echo "‚úÖ PostgreSQL ready"
              break
            fi
            sleep 2
          done

          echo "üß™ Running comprehensive extension tests..."
          cd scripts/test
          if ! bun run test-all-extensions-functional.ts --container=pg-ext-test; then
            echo "‚ùå Extension tests failed"
            docker logs pg-ext-test --tail=100
            docker stop pg-ext-test
            docker rm pg-ext-test
            exit 1
          fi

          docker stop pg-ext-test
          docker rm pg-ext-test
          echo "‚úÖ All extension tests passed!"

      - name: Deploy and test primary stack
        run: |
          set -euo pipefail  # Exit on any error

          echo "üöÄ Deploying primary stack..."
          cd stacks/primary

          # Function for cleanup
          cleanup() {
            echo "Cleaning up..."
            docker compose -f compose.yml -f compose.dev.yml logs --tail=100 || true
            docker compose -f compose.yml -f compose.dev.yml down -v || true
          }
          trap cleanup EXIT ERR  # Cleanup on exit or error

          # Generate test-only credentials (NOT for production)
          TEST_POSTGRES_PASS="test_pg_${GITHUB_RUN_ID}_$(date +%s)"
          TEST_PGBOUNCER_PASS="test_pgb_${GITHUB_RUN_ID}_$(date +%s)"
          TEST_REPLICATION_PASS="test_repl_${GITHUB_RUN_ID}_$(date +%s)"

          # Create .env file
          cat > .env << EOF
          POSTGRES_PASSWORD=${TEST_POSTGRES_PASS}
          PGBOUNCER_AUTH_PASS=${TEST_PGBOUNCER_PASS}
          PG_REPLICATION_PASSWORD=${TEST_REPLICATION_PASS}
          POSTGRES_IMAGE=aza-pg:test
          POSTGRES_MEMORY_LIMIT=2g
          EOF

          # Start stack
          docker compose up -d

          echo "‚è≥ Waiting for services to be healthy..."
          sleep 30

          # Check service health
          docker compose ps

          echo "üß™ Testing direct PostgreSQL connection..."
          if ! docker compose exec -T postgres psql -U postgres -c "SELECT version();"; then
            echo "‚ùå Direct PostgreSQL connection failed"
            touch /tmp/test-failed
            exit 1
          fi

          echo "üß™ Testing PgBouncer connection..."
          if ! PGPASSWORD=${TEST_PGBOUNCER_PASS} docker compose exec -T pgbouncer \
            psql -h localhost -p 6432 -U pgbouncer_auth -d postgres -c "SHOW POOLS;"; then
            echo "‚ùå PgBouncer connection failed"
            touch /tmp/test-failed
            exit 1
          fi

          echo "üß™ Testing postgres_exporter metrics..."
          if ! docker compose exec -T postgres_exporter wget -q -O - http://localhost:9187/metrics | head -20; then
            echo "‚ùå postgres_exporter metrics failed"
            touch /tmp/test-failed
            exit 1
          fi

          echo "üìä Stack logs..."
          docker compose logs --tail=50

          echo "‚úÖ Primary stack test passed!"

      - name: Check test results
        if: always()
        run: |
          if [ -f /tmp/test-failed ]; then
            echo "::error::Primary stack tests failed"
            exit 1
          fi

    outputs:
      test-status: success

  test-replica-stack:
    name: Test Replica Stack
    runs-on: ubuntu-latest
    needs: [build, merge]
    if: github.event.inputs.push_image == 'true'
    timeout-minutes: 25

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Parse Bun version from .tool-versions
        id: bun-version
        run: |
          BUN_VERSION=$(grep '^bun ' .tool-versions | awk '{print $2}' | head -1)
          echo "version=${BUN_VERSION}" >> $GITHUB_OUTPUT

      - name: Set up Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ steps.bun-version.outputs.version }}

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull built image
        run: |
          echo "üì¶ Pulling image for replica stack testing..."
          for i in {1..3}; do
            if docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}; then
              echo "‚úÖ Image pulled successfully"
              break
            else
              echo "‚ö†Ô∏è Pull attempt $i failed, retrying in $((i * 5)) seconds..."
              sleep $((i * 5))
              if [ $i -eq 3 ]; then
                echo "‚ùå Failed to pull image after 3 attempts"
                exit 1
              fi
            fi
          done
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} aza-pg:pg18

      - name: Run replica stack tests
        run: |
          set -euo pipefail
          echo "üß™ Running replica stack tests..."

          cd "$GITHUB_WORKSPACE"
          if ! bun scripts/test/test-replica-stack.ts; then
            echo "‚ùå Replica stack tests failed"
            exit 1
          fi

          echo "‚úÖ Replica stack tests passed!"

      - name: Check test results
        if: always()
        run: |
          if [ -f /tmp/test-failed ]; then
            echo "::error::Replica stack tests failed"
            exit 1
          fi

  test-single-stack:
    name: Test Single Stack
    runs-on: ubuntu-latest
    needs: [build, merge]
    if: github.event.inputs.push_image == 'true'
    timeout-minutes: 20

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Parse Bun version from .tool-versions
        id: bun-version
        run: |
          BUN_VERSION=$(grep '^bun ' .tool-versions | awk '{print $2}' | head -1)
          echo "version=${BUN_VERSION}" >> $GITHUB_OUTPUT

      - name: Set up Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ steps.bun-version.outputs.version }}

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull built image
        run: |
          echo "üì¶ Pulling image for single stack testing..."
          for i in {1..3}; do
            if docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}; then
              echo "‚úÖ Image pulled successfully"
              break
            else
              echo "‚ö†Ô∏è Pull attempt $i failed, retrying in $((i * 5)) seconds..."
              sleep $((i * 5))
              if [ $i -eq 3 ]; then
                echo "‚ùå Failed to pull image after 3 attempts"
                exit 1
              fi
            fi
          done
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} aza-pg:pg18

      - name: Run single stack tests
        run: |
          set -euo pipefail
          echo "üß™ Running single stack tests..."

          cd "$GITHUB_WORKSPACE"
          if ! bun scripts/test/test-single-stack.ts; then
            echo "‚ùå Single stack tests failed"
            exit 1
          fi

          echo "‚úÖ Single stack tests passed!"

      - name: Check test results
        if: always()
        run: |
          if [ -f /tmp/test-failed ]; then
            echo "::error::Single stack tests failed"
            exit 1
          fi
