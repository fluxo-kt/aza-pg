# ============================================================================
# Build PostgreSQL Image - Manual Development Workflow
# ============================================================================
#
# PURPOSE:
# --------
# This workflow is for developers and QA to manually test PostgreSQL image
# builds with different extension versions BEFORE releasing to production.
#
# WHO SHOULD USE THIS:
# -------------------
# - Developers: Testing extension version combinations
# - QA/Validation: Multi-platform compatibility checks (amd64 + arm64)
# - Pre-release validation before merging to 'release' branch
#
# WHEN TO USE THIS:
# ----------------
# MANUAL TRIGGER (GitHub UI or gh CLI):
#   1. You want to test a custom combination of extension versions
#   2. You're validating arm64 compatibility (native ARM64 runners)
#   3. You're verifying a new extension or extension version works
#   4. Before creating a PR/release candidate that should be published
#
# DO NOT USE THIS FOR:
# -------------------
# - Automatic CI on commits (use ci.yml for fast validation)
# - Production releases (use publish.yml when pushing to 'release' branch)
# - Simple validation (use local 'bun run build' or 'bun run validate')
#
# WHAT IT DOES:
# -----------
# 1. Lint & Validate: Fast syntax checks, manifest validation, smoke tests
# 2. Build: Single or multi-platform based on push_image input
#    - push_image=false: Single-platform amd64, local load (no push)
#    - push_image=true: Multi-platform (amd64 + arm64 native), push to registry
# 3. Test: Extension loading, auto-config, primary/replica/single stacks
# 4. Scan: Trivy security vulnerability scan
# 5. Output: Full test report, image digest, SHA hashes
#
# BUILD METHOD:
# ------------
# When push_image=true:
#   - Native builds on platform-specific runners (no QEMU emulation)
#   - amd64: ubuntu-latest (x86_64)
#   - arm64: ubuntu-24.04-arm (ARM64 native)
#   - Builds run in parallel for faster execution
#   - Each platform pushes by digest
#   - Final manifest combines both architectures
#
# When push_image=false:
#   - Single-platform amd64 build
#   - No push to registry (local load only)
#   - Fast iteration for local testing
#
# HOW TO TRIGGER:
# ---------------
# GitHub UI:
#   Actions tab â†’ "Build PostgreSQL Image" â†’ "Run workflow"
#   Choose branch and optional version inputs
#
# GitHub CLI:
#   gh workflow run build-postgres-image.yml -r main
#   gh workflow run build-postgres-image.yml -r main \
#     -f pg_version=18 \
#     -f pgvector_version=0.8.1 \
#     -f pg_cron_version=1.6.7 \
#     -f pgaudit_version=18.0 \
#     -f push_image=true
#
# OUTPUTS:
# --------
# - Built image (local by default, push optional via 'push_image' input)
# - Dev-prefixed tags if pushed (e.g., dev-main, dev-main-abc123)
# - Full SBOM and provenance (only when pushed)
# - Test results in GitHub Actions UI
# - Step summary with extension catalog, versions, test status
#
# DIFFERENCES FROM OTHER WORKFLOWS:
# --------------------------------
# vs ci.yml:     No Docker build (ci.yml only validates code/configs)
# vs publish.yml: Manual trigger (publish.yml auto-runs on 'release' branch)
#                 More detailed testing (publish.yml is minimal pre-signature)
#                 Different tagging strategy (build.yml uses dev-prefixed tags)
#                 No push by default (publish.yml always pushes production tags)
#                 No Cosign signing (dev builds only)
#
# TROUBLESHOOTING:
# ---------------
# Failed tests â†’ Check GitHub Actions logs in "Test PostgreSQL Stack" section
# arm64 timeout â†’ Native builds should be fast; check logs for actual error
# Push fails â†’ May need GHCR write permissions or GITHUB_TOKEN with packages scope
# Build fails â†’ Run locally: bun run build or check Dockerfile for syntax
#
# RELATED DOCUMENTATION:
# ----------------------
# - CLAUDE.md - Development standards and fast paths
# - scripts/build.ts - Local build script (Bun TypeScript)
#
# ============================================================================

name: Build PostgreSQL Image

on:
  workflow_dispatch:
    inputs:
      push_image:
        description: "Push image to registry (for QA/testing only)"
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  lint:
    name: Lint and Validate
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Bun and dependencies
        uses: ./.github/actions/setup-bun

      - name: Run full validation
        run: bun run validate:all

      - name: Check documentation consistency
        run: bun scripts/check-docs-consistency.ts

      - name: Run smoke tests
        run: bun scripts/test-smoke.ts

      - name: Verify manifest sync
        run: bun scripts/verify-generated.ts

      - name: Validate workflow defaults
        run: bun scripts/ci/validate-workflow-defaults.ts

  build:
    name: Build PostgreSQL Image (${{ matrix.platform }})
    runs-on: ${{ matrix.runner }}
    needs: lint
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
            artifact: linux-amd64
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
            artifact: linux-arm64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Validate Dockerfile paths
        run: bun scripts/build/validate-dockerfile-paths.ts

      - name: Set up Docker Buildx
        uses: ./.github/actions/setup-buildx

      - name: Log in to GitHub Container Registry
        if: github.event.inputs.push_image == 'true'
        uses: ./.github/actions/ghcr-login
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch,prefix=dev-
            type=sha,prefix=dev-{{branch}}-,format=short
          labels: |
            org.opencontainers.image.title=aza-pg-testing PostgreSQL Development Image
            org.opencontainers.image.description=PostgreSQL 18 with extensions (dev build)
            org.opencontainers.image.vendor=fluxo-kt

      - name: Set up Bun and dependencies
        uses: ./.github/actions/setup-bun

      - name: Generate cache key
        id: cache-key
        run: |
          set -euo pipefail
          CONTENT_HASH="${{ hashFiles('docker/**', 'scripts/extensions/**', 'bun.lock', 'package.json') }}"
          CACHE_KEY="build-cache-${{ github.ref_name }}-${CONTENT_HASH}-${{ matrix.artifact }}"
          echo "key=${CACHE_KEY}" >> $GITHUB_OUTPUT
          echo "content_hash=${CONTENT_HASH}" >> $GITHUB_OUTPUT
          echo "Generated cache key: ${CACHE_KEY}"

      - name: Build and push by digest (multi-platform)
        id: build
        if: github.event.inputs.push_image == 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/postgres/Dockerfile
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push-by-digest=true,name-canonical=true,push=true,oci-mediatypes=true
          cache-from: |
            type=gha,scope=aza-pg-${{ matrix.artifact }}
            type=gha,scope=aza-pg-base
          cache-to: type=gha,mode=max,scope=aza-pg-${{ matrix.artifact }}
          # BuildKit provenance disabled to prevent potential secret leakage via build args
          # Dev builds don't use GitHub attestation action (publish.yml only)
          provenance: false
          sbom: true

      - name: Build and load (local only)
        id: build-local
        if: github.event.inputs.push_image != 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/postgres/Dockerfile
          platforms: ${{ matrix.platform }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          load: true
          cache-from: |
            type=gha,scope=aza-pg-${{ matrix.artifact }}
            type=gha,scope=aza-pg-base
          cache-to: type=gha,mode=max,scope=aza-pg-${{ matrix.artifact }}
          provenance: false
          sbom: false

      - name: Export digest (multi-platform)
        if: github.event.inputs.push_image == 'true'
        run: |
          set -euo pipefail
          mkdir -p ${{ runner.temp }}/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "${{ runner.temp }}/digests/${digest#sha256:}"
          echo "Exported digest: ${digest}"

      - name: Upload digest (multi-platform)
        if: github.event.inputs.push_image == 'true'
        uses: actions/upload-artifact@v5
        with:
          name: digests-${{ matrix.artifact }}
          path: ${{ runner.temp }}/digests/*
          if-no-files-found: error
          retention-days: 1

      - name: Monitor cache usage
        if: always()
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          bun scripts/ci/monitor-cache-usage.ts \
            --repository ${{ github.repository }} \
            --platform "${{ matrix.platform }}" \
            --github-summary

      - name: Output build information (amd64 only)
        if: matrix.platform == 'linux/amd64'
        run: |
          set -euo pipefail
          DIGEST="${{ github.event.inputs.push_image == 'true' && steps.build.outputs.digest || steps.build-local.outputs.digest }}"
          bun scripts/ci/verify-build-output.ts \
            --image="${{ steps.meta.outputs.tags }}" \
            --platform="${{ matrix.platform }}" \
            --digest="${DIGEST}" \
            --push-image="${{ github.event.inputs.push_image }}" \
            --github-summary

      - name: Verify local image
        if: github.event.inputs.push_image != 'true' && matrix.platform == 'linux/amd64'
        run: |
          set -euo pipefail
          bun scripts/ci/verify-local-image-with-fallback.ts \
            --image-ref="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}" \
            --ref-name="${{ github.ref_name }}"

  merge:
    name: Create Multi-Platform Manifest
    runs-on: ubuntu-latest
    needs: build
    if: github.event.inputs.push_image == 'true'
    timeout-minutes: 15
    outputs:
      image_digest: ${{ steps.merge.outputs.digest }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Bun and dependencies
        uses: ./.github/actions/setup-bun

      - name: Download digests
        uses: actions/download-artifact@v6
        with:
          pattern: digests-*
          path: ${{ runner.temp }}/digests
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: ./.github/actions/setup-buildx

      - name: Log in to GitHub Container Registry
        uses: ./.github/actions/ghcr-login
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create manifest list and push
        id: merge
        run: |
          set -euo pipefail
          bun scripts/ci/merge-multi-platform-manifest.ts \
            --registry="${{ env.REGISTRY }}" \
            --repository="${{ env.IMAGE_NAME }}" \
            --tag="dev-${{ github.ref_name }}" \
            --sha="${{ github.sha }}" \
            --digests-dir="${{ runner.temp }}/digests" \
            --github-output

      - name: Verify image
        run: |
          set -euo pipefail
          bun scripts/docker/pull-with-retry.ts \
            --image "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}" \
            --max-retries 3
          docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} psql --version
          echo "âœ… PostgreSQL version verified"

      - name: Output manifest digest
        run: |
          set -euo pipefail
          echo "### Multi-Platform Manifest Created :package:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Manifest Digest:** \`${{ steps.merge.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`dev-${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`dev-${{ github.ref_name }}-${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Platforms:**" >> $GITHUB_STEP_SUMMARY
          echo "- linux/amd64 (native build on ubuntu-latest)" >> $GITHUB_STEP_SUMMARY
          echo "- linux/arm64 (native build on ubuntu-24.04-arm)" >> $GITHUB_STEP_SUMMARY

  scan-image:
    name: Scan Image for Vulnerabilities
    runs-on: ubuntu-latest
    needs: build
    if: always() && needs.build.result == 'success'
    timeout-minutes: 15
    permissions:
      contents: read
      security-events: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Log in to GitHub Container Registry
        if: github.event.inputs.push_image == 'true'
        uses: ./.github/actions/ghcr-login
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Bun and dependencies
        if: github.event.inputs.push_image == 'true'
        uses: ./.github/actions/setup-bun

      - name: Pull built image (pushed)
        if: github.event.inputs.push_image == 'true'
        run: |
          set -euo pipefail
          bun scripts/docker/pull-with-retry.ts \
            --image "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}" \
            --max-retries 3
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} aza-pg-testing:scan
          echo "ðŸ“¦ Scanning image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}"

      - name: Use local image (not pushed)
        if: github.event.inputs.push_image != 'true'
        run: |
          set -euo pipefail
          echo "ðŸ” Using locally built image for security scan..."
          # When loaded locally, image name may not include registry prefix
          # Try with registry prefix first, fallback to finding local tag
          if docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }} aza-pg-testing:scan 2>/dev/null; then
            echo "ðŸ“¦ Tagged image with registry prefix for scanning"
          else
            # Find the locally built image by tag pattern
            LOCAL_IMAGE=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'dev-${{ github.ref_name }}$' | head -1)
            if [ -n "$LOCAL_IMAGE" ]; then
              docker tag "$LOCAL_IMAGE" aza-pg-testing:scan
              echo "ðŸ“¦ Tagged local image $LOCAL_IMAGE for scanning"
            else
              echo "âŒ Could not find locally built image"
              exit 1
            fi
          fi

      - name: Cache Trivy vulnerability database
        uses: actions/cache@v4
        with:
          path: .trivy-cache
          key: trivy-db-${{ runner.os }}-${{ hashFiles('.github/workflows/build-postgres-image.yml') }}
          restore-keys: |
            trivy-db-${{ runner.os }}-

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.33.1
        env:
          TRIVY_CACHE_DIR: .trivy-cache
        with:
          image-ref: "aza-pg-testing:scan"
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH"

      - name: Upload Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        if: always() && hashFiles('trivy-results.sarif') != ''
        with:
          sarif_file: "trivy-results.sarif"

      - name: Run Trivy for console output
        uses: aquasecurity/trivy-action@0.33.1
        env:
          TRIVY_CACHE_DIR: .trivy-cache
        with:
          image-ref: "aza-pg-testing:scan"
          format: "table"
          severity: "CRITICAL,HIGH,MEDIUM"
          exit-code: "1" # Fail build on CRITICAL/HIGH vulnerabilities

      - name: Capture security scan diagnostics on failure
        if: failure()
        run: |
          set -euo pipefail
          bun scripts/debug/capture-scan-diagnostics.ts \
            --image "aza-pg-testing:scan" \
            --output-dir "${{ runner.temp }}/scan-diagnostics" \
            --cache-dir .trivy-cache

      - name: Upload security scan failure diagnostics
        if: failure()
        uses: actions/upload-artifact@v5
        with:
          name: scan-failure-diagnostics-${{ github.sha }}
          path: ${{ runner.temp }}/scan-diagnostics/*
          if-no-files-found: warn
          retention-days: 7

      - name: Generate vulnerability summary
        if: always()
        run: |
          set -euo pipefail
          echo "### Security Scan Results :shield:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.push_image }}" == "true" ]; then
            DIGEST="${{ needs.merge.outputs.image_digest }}"
          echo "**Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${DIGEST:0:12}\`" >> $GITHUB_STEP_SUMMARY
          else
            TAG="dev-${{ github.ref_name }}"
          echo "**Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}\` (local build)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Severity Filter:** CRITICAL, HIGH" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Scan completed. Check Security tab for details (if pushed)." >> $GITHUB_STEP_SUMMARY

  test:
    name: Test PostgreSQL Stack
    runs-on: ubuntu-latest
    needs: [build, merge]
    if: github.event.inputs.push_image == 'true'
    timeout-minutes: 25

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up test environment
        if: github.event.inputs.push_image == 'true'
        uses: ./.github/actions/test-job-setup
        with:
          ghcr-login: "true"
          ghcr-token: ${{ secrets.GITHUB_TOKEN }}
          image-source: registry
          image-name: aza-pg-testing:test
          registry-image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}

      - name: Test extension loading
        run: |
          set -euo pipefail
          echo "ðŸ§ª Testing extension loading..."
          docker run -d --name pg-test \
            -e POSTGRES_PASSWORD=test \
            aza-pg-testing:test

          echo "â³ Waiting for PostgreSQL to start..."
          for i in {1..30}; do
            if docker exec pg-test pg_isready -U postgres > /dev/null 2>&1; then
              echo "âœ… PostgreSQL ready"
              break
            fi
            sleep 2
          done

          docker exec pg-test psql -U postgres -c "CREATE EXTENSION vector;"
          docker exec pg-test psql -U postgres -c "CREATE EXTENSION pg_trgm;"
          docker exec pg-test psql -U postgres -c "CREATE EXTENSION pg_stat_statements;"
          docker exec pg-test psql -U postgres -c "CREATE EXTENSION pg_cron;"
          docker exec pg-test psql -U postgres -c "CREATE EXTENSION pgaudit;"

          echo "ðŸ” Verifying extensions functional..."
          EXT_LIST=$(docker exec pg-test psql -U postgres -tAc \
            "SELECT extname FROM pg_extension \
             WHERE extname IN ('vector', 'pg_trgm', 'pg_stat_statements', \
                               'pg_cron', 'pgaudit') ORDER BY extname;")
          echo "$EXT_LIST" | grep -q "pg_cron" || { echo "âŒ pg_cron not found"; exit 1; }
          echo "$EXT_LIST" | grep -q "pg_stat_statements" || { echo "âŒ pg_stat_statements not found"; exit 1; }
          echo "$EXT_LIST" | grep -q "pg_trgm" || { echo "âŒ pg_trgm not found"; exit 1; }
          echo "$EXT_LIST" | grep -q "pgaudit" || { echo "âŒ pgaudit not found"; exit 1; }
          echo "$EXT_LIST" | grep -q "vector" || { echo "âŒ vector not found"; exit 1; }
          echo "âœ… All 5 extensions installed"

          TRGM_TEST=$(docker exec pg-test psql -U postgres -tAc "SELECT similarity('test', 'test');")
          echo "$TRGM_TEST" | grep -q "1" || { echo "âŒ pg_trgm test failed (expected 1, got: $TRGM_TEST)"; exit 1; }
          echo "âœ… pg_trgm functional"

          VECTOR_TEST=$(docker exec pg-test psql -U postgres -tAc "SELECT '[1,2,3]'::vector;")
          echo "$VECTOR_TEST" | grep -q "\[1,2,3\]" || { echo "âŒ vector test failed (got: $VECTOR_TEST)"; exit 1; }
          echo "âœ… vector functional"

          docker stop pg-test
          docker rm pg-test
          echo "âœ… Extensions test passed!"

      - name: Test auto-config with different memory limits
        run: |
          set -euo pipefail
          echo "ðŸ§ª Testing auto-config with 2GB memory limit..."
          docker run -d --name pg-test-2gb \
            -e POSTGRES_PASSWORD=test \
            --memory=2g \
            aza-pg-testing:test

          for i in {1..30}; do
            if docker exec pg-test-2gb pg_isready -U postgres > /dev/null 2>&1; then
              break
            fi
            sleep 2
          done

          echo "Checking auto-config logs for 2GB..."
          docker logs pg-test-2gb 2>&1 | grep -i "detected ram" || true
          docker logs pg-test-2gb 2>&1 | grep -i "shared_buffers" || true

          docker exec pg-test-2gb psql -U postgres -c "SHOW shared_buffers;"
          docker exec pg-test-2gb psql -U postgres -c "SHOW max_connections;"

          docker stop pg-test-2gb
          docker rm pg-test-2gb

          echo "ðŸ§ª Testing auto-config with 4GB memory limit..."
          docker run -d --name pg-test-4gb \
            -e POSTGRES_PASSWORD=test \
            --memory=4g \
            aza-pg-testing:test

          for i in {1..30}; do
            if docker exec pg-test-4gb pg_isready -U postgres > /dev/null 2>&1; then
              break
            fi
            sleep 2
          done

          echo "Checking auto-config logs for 4GB..."
          docker logs pg-test-4gb 2>&1 | grep -i "detected ram" || true
          docker logs pg-test-4gb 2>&1 | grep -i "shared_buffers" || true

          docker exec pg-test-4gb psql -U postgres -c "SHOW shared_buffers;"
          docker exec pg-test-4gb psql -U postgres -c "SHOW max_connections;"

          docker stop pg-test-4gb
          docker rm pg-test-4gb
          echo "âœ… Auto-config test passed!"

      - name: Test all extensions (comprehensive)
        run: |
          set -euo pipefail
          # Derive enabled extension count dynamically
          eval "$(bun scripts/derive-catalog-stats.ts --format=shell)"
          echo "ðŸ§ª Testing all ${CATALOG_ENABLED} enabled catalog entries comprehensively..."
          docker run -d --name pg-ext-test \
            -e POSTGRES_PASSWORD=test \
            --memory=4g \
            aza-pg-testing:test

          echo "â³ Waiting for PostgreSQL to start..."
          for i in {1..30}; do
            if docker exec pg-ext-test pg_isready -U postgres > /dev/null 2>&1; then
              echo "âœ… PostgreSQL ready"
              break
            fi
            sleep 2
          done

          echo "ðŸ§ª Running comprehensive extension tests..."
          cd scripts/test
          if ! bun run test-all-extensions-functional.ts --container=pg-ext-test; then
            echo "âŒ Extension tests failed"
            docker logs pg-ext-test --tail=100
            docker stop pg-ext-test
            docker rm pg-ext-test
            exit 1
          fi

          docker stop pg-ext-test
          docker rm pg-ext-test
          echo "âœ… All extension tests passed!"

      - name: Deploy and test primary stack
        run: |
          set -euo pipefail  # Exit on any error

          echo "ðŸš€ Deploying primary stack..."
          cd stacks/primary

          # Function for cleanup
          cleanup() {
            echo "Cleaning up..."
            docker compose -f compose.yml -f compose.dev.yml logs --tail=100 || true
            docker compose -f compose.yml -f compose.dev.yml down -v || true
          }
          trap cleanup EXIT ERR  # Cleanup on exit or error

          # Generate test-only credentials (NOT for production)
          TEST_POSTGRES_PASS="test_pg_${GITHUB_RUN_ID}_$(date +%s)"
          TEST_PGBOUNCER_PASS="test_pgb_${GITHUB_RUN_ID}_$(date +%s)"
          TEST_REPLICATION_PASS="test_repl_${GITHUB_RUN_ID}_$(date +%s)"

          # Create .env file
          cat > .env << EOF
          POSTGRES_PASSWORD=${TEST_POSTGRES_PASS}
          PGBOUNCER_AUTH_PASS=${TEST_PGBOUNCER_PASS}
          PG_REPLICATION_PASSWORD=${TEST_REPLICATION_PASS}
          POSTGRES_IMAGE=aza-pg-testing:test
          POSTGRES_MEMORY_LIMIT=2g
          EOF

          # Start stack
          docker compose up -d

          echo "â³ Waiting for services to be healthy..."
          sleep 30

          # Check service health
          docker compose ps

          echo "ðŸ§ª Testing direct PostgreSQL connection..."
          if ! docker compose exec -T postgres psql -U postgres -c "SELECT version();"; then
            echo "âŒ Direct PostgreSQL connection failed"
            touch /tmp/test-failed
            exit 1
          fi

          echo "ðŸ§ª Testing PgBouncer connection..."
          if ! PGPASSWORD=${TEST_PGBOUNCER_PASS} docker compose exec -T pgbouncer \
            psql -h localhost -p 6432 -U pgbouncer_auth -d postgres -c "SHOW POOLS;"; then
            echo "âŒ PgBouncer connection failed"
            touch /tmp/test-failed
            exit 1
          fi

          echo "ðŸ§ª Testing postgres_exporter metrics..."
          if ! docker compose exec -T postgres_exporter wget -q -O - http://localhost:9187/metrics | head -20; then
            echo "âŒ postgres_exporter metrics failed"
            touch /tmp/test-failed
            exit 1
          fi

          echo "ðŸ“Š Stack logs..."
          docker compose logs --tail=50

          echo "âœ… Primary stack test passed!"

      - name: Check test results
        if: always()
        run: |
          set -euo pipefail
          if [ -f /tmp/test-failed ]; then
            echo "::error::Primary stack tests failed"
            exit 1
          fi

      - name: Capture PostgreSQL logs on failure
        if: failure()
        run: |
          set -euo pipefail
          bun scripts/debug/capture-postgres-diagnostics.ts \
            --container pg-ext-test \
            --output-dir "${{ runner.temp }}/diagnostics"

      - name: Upload test failure diagnostics
        if: failure()
        uses: actions/upload-artifact@v5
        with:
          name: test-failure-diagnostics-${{ github.sha }}
          path: ${{ runner.temp }}/diagnostics/*
          if-no-files-found: warn
          retention-days: 7

    outputs:
      test-status: success

  test-replica-stack:
    name: Test Replica Stack
    runs-on: ubuntu-latest
    needs: [build, merge]
    if: github.event.inputs.push_image == 'true'
    timeout-minutes: 25

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up test environment
        if: github.event.inputs.push_image == 'true'
        uses: ./.github/actions/test-job-setup
        with:
          ghcr-login: "true"
          ghcr-token: ${{ secrets.GITHUB_TOKEN }}
          image-source: registry
          image-name: aza-pg-testing:pg18
          registry-image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}

      - name: Run replica stack tests
        run: |
          set -euo pipefail
          echo "ðŸ§ª Running replica stack tests..."

          cd "$GITHUB_WORKSPACE"
          if ! bun scripts/test/test-replica-stack.ts; then
            echo "âŒ Replica stack tests failed"
            exit 1
          fi

          echo "âœ… Replica stack tests passed!"

      - name: Check test results
        if: always()
        run: |
          set -euo pipefail
          if [ -f /tmp/test-failed ]; then
            echo "::error::Replica stack tests failed"
            exit 1
          fi

      - name: Capture test diagnostics
        if: failure()
        uses: ./.github/actions/capture-test-diagnostics
        with:
          test-type: replica-stack
          containers: all
          artifact-prefix: replica-test
          retention-days: 7

  test-single-stack:
    name: Test Single Stack
    runs-on: ubuntu-latest
    needs: [build, merge]
    if: github.event.inputs.push_image == 'true'
    timeout-minutes: 20

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up test environment
        if: github.event.inputs.push_image == 'true'
        uses: ./.github/actions/test-job-setup
        with:
          ghcr-login: "true"
          ghcr-token: ${{ secrets.GITHUB_TOKEN }}
          image-source: registry
          image-name: aza-pg-testing:pg18
          registry-image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ github.ref_name }}

      - name: Run single stack tests
        run: |
          set -euo pipefail
          echo "ðŸ§ª Running single stack tests..."

          cd "$GITHUB_WORKSPACE"
          if ! bun scripts/test/test-single-stack.ts; then
            echo "âŒ Single stack tests failed"
            exit 1
          fi

          echo "âœ… Single stack tests passed!"

      - name: Check test results
        if: always()
        run: |
          set -euo pipefail
          if [ -f /tmp/test-failed ]; then
            echo "::error::Single stack tests failed"
            exit 1
          fi

      - name: Capture test diagnostics
        if: failure()
        uses: ./.github/actions/capture-test-diagnostics
        with:
          test-type: single-stack
          containers: all
          artifact-prefix: single-test
          retention-days: 7
