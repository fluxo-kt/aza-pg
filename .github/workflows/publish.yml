name: Publish Single-Node Image

on:
  push:
    branches:
      - release

concurrency:
  group: publish-${{ github.ref }}
  cancel-in-progress: false # Don't cancel in-progress releases

permissions:
  contents: read
  packages: write
  id-token: write
  security-events: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  publish:
    name: Build and Publish Single-Node Image
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Parse Bun version from .tool-versions
        id: bun-version
        run: |
          BUN_VERSION=$(grep '^bun ' .tool-versions | awk '{print $2}' | head -1)
          echo "version=${BUN_VERSION}" >> $GITHUB_OUTPUT

      - name: Set up Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ steps.bun-version.outputs.version }}

      - name: Install dependencies
        run: bun install --frozen-lockfile
        env:
          BUN_CONFIG_INSTALL_MINIMUM_RELEASE_AGE: "86400" # 1 day delay for supply chain security

      - name: Validate manifest
        run: bun run validate

      - name: Derive catalog statistics
        id: catalog
        run: |
          eval "$(bun scripts/derive-catalog-stats.ts --format=shell)"
          echo "total=${CATALOG_TOTAL}" >> $GITHUB_OUTPUT
          echo "enabled=${CATALOG_ENABLED}" >> $GITHUB_OUTPUT
          echo "disabled=${CATALOG_DISABLED}" >> $GITHUB_OUTPUT
          echo "Catalog: ${CATALOG_ENABLED} enabled, ${CATALOG_TOTAL} total, ${CATALOG_DISABLED} disabled"

      - name: Extract PostgreSQL version from base image
        id: pg-version
        run: |
          # Extract major version and SHA from Dockerfile
          PG_MAJOR=$(grep -m1 '^ARG PG_VERSION=' docker/postgres/Dockerfile | cut -d'=' -f2)
          PG_BASE_SHA=$(grep -m1 '^ARG PG_BASE_IMAGE_SHA=' docker/postgres/Dockerfile | cut -d'=' -f2)

          echo "Pulling base image to determine actual PostgreSQL version..."
          for i in {1..3}; do
            if docker pull postgres:${PG_MAJOR}-trixie@${PG_BASE_SHA}; then
              echo "âœ… Base image pulled successfully"
              break
            else
              echo "âš ï¸ Pull attempt $i failed, retrying in $((i * 5)) seconds..."
              sleep $((i * 5))
              if [ $i -eq 3 ]; then
                echo "âŒ Failed to pull base image after 3 attempts"
                exit 1
              fi
            fi
          done

          # Extract actual PostgreSQL version from base image
          PG_VERSION_OUTPUT=$(docker run --rm postgres:${PG_MAJOR}-trixie@${PG_BASE_SHA} psql --version)
          echo "PostgreSQL version output: ${PG_VERSION_OUTPUT}"

          # Parse version (format: "psql (PostgreSQL) 18.1 (Debian 18.1-1.pgdg130+1)")
          PG_FULL=$(echo "${PG_VERSION_OUTPUT}" | grep -oP '\d+\.\d+' | head -1)
          PG_MINOR=$(echo "${PG_FULL}" | cut -d'.' -f2)

          # Capture base image digest for provenance
          BASE_IMAGE="docker.io/library/postgres:${PG_MAJOR}-trixie"
          BASE_DIGEST=$(docker inspect postgres:${PG_MAJOR}-trixie@${PG_BASE_SHA} \
            --format='{{index .RepoDigests 0}}' | cut -d'@' -f2)

          echo "major=${PG_MAJOR}" >> $GITHUB_OUTPUT
          echo "minor=${PG_MINOR}" >> $GITHUB_OUTPUT
          echo "full=${PG_FULL}" >> $GITHUB_OUTPUT
          echo "base_image_name=${BASE_IMAGE}" >> $GITHUB_OUTPUT
          echo "base_image_digest=${BASE_DIGEST}" >> $GITHUB_OUTPUT
          echo "âœ… Actual PostgreSQL version from base image: ${PG_FULL}"
          echo "âœ… Base image digest: ${BASE_DIGEST}"

      - name: Generate build timestamp
        id: timestamp
        run: |
          BUILD_TS=$(date -u '+%Y%m%d%H%M')
          echo "value=${BUILD_TS}" >> $GITHUB_OUTPUT
          echo "Build timestamp: ${BUILD_TS}"

      - name: Generate version tags
        id: tags
        run: |
          PG_FULL="${{ steps.pg-version.outputs.full }}"
          PG_MAJOR="${{ steps.pg-version.outputs.major }}"
          BUILD_TS="${{ steps.timestamp.outputs.value }}"

          # Primary versioned tag: MM.mm-TS-TYPE
          VERSIONED_TAG="${PG_FULL}-${BUILD_TS}-single-node"

          # Convenience tags
          CONVENIENCE_TAGS="${PG_FULL}-single-node,${PG_MAJOR}-single-node,${PG_FULL},${PG_MAJOR}"

          echo "versioned=${VERSIONED_TAG}" >> $GITHUB_OUTPUT
          echo "convenience=${CONVENIENCE_TAGS}" >> $GITHUB_OUTPUT

          echo "Primary tag: ${VERSIONED_TAG}"
          echo "Convenience tags: ${CONVENIENCE_TAGS}"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
            network=host

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Document existing tags (for rollback reference)
        continue-on-error: true
        run: |
          echo "### Tag Overwrite Reference" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The following tags will be updated. Previous digests recorded for rollback reference:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          for TAG in "${{ steps.pg-version.outputs.full }}-single-node" \
                     "${{ steps.pg-version.outputs.major }}-single-node" \
                     "${{ steps.pg-version.outputs.full }}" \
                     "${{ steps.pg-version.outputs.major }}"; do
            if PREV_DIGEST=$(docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG} 2>/dev/null | \
                             jq -r '.manifests[0].digest // .digest' 2>/dev/null); then
              echo "- **${TAG}**: Previous digest \`${PREV_DIGEST}\`" >> $GITHUB_STEP_SUMMARY
              echo "Previous ${TAG}: ${PREV_DIGEST}"
            else
              echo "- **${TAG}**: New tag (no previous version)" >> $GITHUB_STEP_SUMMARY
              echo "${TAG}: New tag"
            fi
          done
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ steps.tags.outputs.versioned }},priority=1000
            type=raw,value=${{ steps.pg-version.outputs.full }}-single-node,priority=900
            type=raw,value=${{ steps.pg-version.outputs.major }}-single-node,priority=800
            type=raw,value=${{ steps.pg-version.outputs.full }},priority=700
            type=raw,value=${{ steps.pg-version.outputs.major }},priority=600
          labels: |
            org.opencontainers.image.title=aza-pg Single-Node PostgreSQL
            org.opencontainers.image.description=PostgreSQL ${{ steps.pg-version.outputs.full }} \
              with ${{ steps.catalog.outputs.total }} extensions - Single-Node
            org.opencontainers.image.vendor=fluxo-kt
            org.opencontainers.image.version=${{ steps.tags.outputs.versioned }}
            org.opencontainers.image.created=${{ steps.timestamp.outputs.value }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.base.name=${{ steps.pg-version.outputs.base_image_name }}
            org.opencontainers.image.base.digest=${{ steps.pg-version.outputs.base_image_digest }}
            io.fluxo-kt.aza-pg.postgres.version=${{ steps.pg-version.outputs.full }}
            io.fluxo-kt.aza-pg.build.timestamp=${{ steps.timestamp.outputs.value }}
            io.fluxo-kt.aza-pg.build.type=single-node
            io.fluxo-kt.aza-pg.extensions.enabled=${{ steps.catalog.outputs.enabled }}
            io.fluxo-kt.aza-pg.extensions.total=${{ steps.catalog.outputs.total }}
          annotations: |
            index,manifest:org.opencontainers.image.title=aza-pg Single-Node PostgreSQL
            index,manifest:org.opencontainers.image.description=PostgreSQL ${{ steps.pg-version.outputs.full }} with ${{ steps.catalog.outputs.total }} extensions
            index,manifest:org.opencontainers.image.vendor=fluxo-kt
            index,manifest:org.opencontainers.image.version=${{ steps.tags.outputs.versioned }}
            index,manifest:org.opencontainers.image.created=${{ steps.timestamp.outputs.value }}
            index,manifest:org.opencontainers.image.revision=${{ github.sha }}
            index,manifest:org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            index,manifest:org.opencontainers.image.url=${{ github.server_url }}/${{ github.repository }}
            index,manifest:org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/main/README.md
            index,manifest:org.opencontainers.image.licenses=Apache-2.0
            index,manifest:org.opencontainers.image.base.name=${{ steps.pg-version.outputs.base_image_name }}
            index,manifest:org.opencontainers.image.base.digest=${{ steps.pg-version.outputs.base_image_digest }}
            index,manifest:io.fluxo-kt.aza-pg.postgres.version=${{ steps.pg-version.outputs.full }}
            index,manifest:io.fluxo-kt.aza-pg.build.type=single-node
            index,manifest:io.fluxo-kt.aza-pg.extensions.enabled=${{ steps.catalog.outputs.enabled }}

      - name: Generate cache key
        id: cache-key
        run: |
          CONTENT_HASH="${{ hashFiles('docker/**', 'scripts/extensions/**', 'bun.lock', 'package.json') }}"
          CACHE_KEY="publish-cache-${{ github.ref_name }}-${CONTENT_HASH}"
          echo "key=${CACHE_KEY}" >> $GITHUB_OUTPUT
          echo "content_hash=${CONTENT_HASH}" >> $GITHUB_OUTPUT
          echo "Generated cache key: ${CACHE_KEY}"

      - name: Build and push to testing tag
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/postgres/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:testing-${{ github.sha }}
          labels: ${{ steps.meta.outputs.labels }}
          annotations: ${{ steps.meta.outputs.annotations }}
          build-args: |
            PG_VERSION=${{ steps.pg-version.outputs.major }}
            BUILD_DATE=${{ steps.timestamp.outputs.value }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.tags.outputs.versioned }}
          cache-from: |
            type=gha,scope=${{ github.ref_name }}
            type=gha,scope=${{ steps.cache-key.outputs.key }}
          cache-to: type=gha,mode=max,scope=${{ steps.cache-key.outputs.key }}
          provenance: true
          sbom: true

      - name: Monitor cache usage
        if: always()
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Checking GitHub Actions cache usage..."

          # Get cache usage from GitHub API
          if CACHE_DATA=$(gh api repos/${{ github.repository }}/actions/cache/usage 2>/dev/null); then
            CACHE_USAGE=$(echo "$CACHE_DATA" | jq -r '.active_caches_size_in_bytes // 0')

            if command -v bc >/dev/null 2>&1; then
              CACHE_GB=$(echo "scale=2; $CACHE_USAGE / 1073741824" | bc)
            else
              # Fallback if bc not available (shouldn't happen on ubuntu-latest)
              CACHE_GB=$(awk "BEGIN {printf \"%.2f\", $CACHE_USAGE / 1073741824}")
            fi

            echo "Current cache usage: ${CACHE_GB}GB"

            # Check if approaching limit
            if command -v bc >/dev/null 2>&1; then
              if (( $(echo "$CACHE_GB > 4" | bc -l) )); then
                echo "âš ï¸ WARNING: Cache usage approaching GitHub limit (5GB)"
                echo "::warning::Cache usage (${CACHE_GB}GB) approaching GitHub limit" && \
                echo "Consider cleaning old cache entries for more space"
              fi
            fi

            # Add to step summary
            echo "### Cache Usage: ${CACHE_GB}GB / 5GB" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            if (( $(echo "$CACHE_GB > 4" | bc -l 2>/dev/null || echo 0) )); then
              echo "âš ï¸ **WARNING:** Approaching GitHub cache limit" >> $GITHUB_STEP_SUMMARY
            else
              echo "âœ… Cache usage within acceptable limits" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âš ï¸ Unable to fetch cache usage data from GitHub API"
            echo "This is informational only and does not affect the build"
          fi

      - name: Verify PostgreSQL version in built image
        id: actual-version
        run: |
          echo "Pulling built image to verify PostgreSQL version..."
          for i in {1..3}; do
            if docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}; then
              echo "âœ… Built image pulled successfully"
              break
            else
              echo "âš ï¸ Pull attempt $i failed, retrying in $((i * 5)) seconds..."
              sleep $((i * 5))
              if [ $i -eq 3 ]; then
                echo "âŒ Failed to pull built image after 3 attempts"
                exit 1
              fi
            fi
          done

          # Extract PostgreSQL version from built image
          PG_VERSION_OUTPUT=$(docker run --rm \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }} \
            psql --version)
          echo "PostgreSQL version output: ${PG_VERSION_OUTPUT}"

          # Parse version
          ACTUAL_VERSION=$(echo "${PG_VERSION_OUTPUT}" | grep -oP '\d+\.\d+' | head -1)

          echo "major=${{ steps.pg-version.outputs.major }}" >> $GITHUB_OUTPUT
          echo "minor=${{ steps.pg-version.outputs.minor }}" >> $GITHUB_OUTPUT
          echo "full=${ACTUAL_VERSION}" >> $GITHUB_OUTPUT

          # Verify version matches what we used for tagging
          if [ "${ACTUAL_VERSION}" != "${{ steps.pg-version.outputs.full }}" ]; then
            echo "âŒ ERROR: Version mismatch (expected ${{ steps.pg-version.outputs.full }})"
            echo "   This should not happen - version was extracted from base image before build"
            exit 1
          fi

          echo "âœ… Version verified: ${ACTUAL_VERSION} matches tagged version"

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: "v2.4.1"

      - name: Sign container image with Cosign (keyless OIDC)
        env:
          DIGEST: ${{ steps.build.outputs.digest }}
          COSIGN_EXPERIMENTAL: "1" # Enable keyless mode (explicit, though default in v2.x)
        run: |
          # Sign by digest (immutable reference)
          echo "Signing image by digest: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${DIGEST}"
          cosign sign --yes "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${DIGEST}"

          # Sign all convenience tags for easier verification
          echo "Signing convenience tags..."
          cosign sign --yes "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tags.outputs.versioned }}"
          cosign sign --yes "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.pg-version.outputs.full }}-single-node"
          TAG_SINGLE="${{ steps.pg-version.outputs.major }}-single-node"
          cosign sign --yes "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG_SINGLE}"
          cosign sign --yes "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.pg-version.outputs.full }}"
          cosign sign --yes "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.pg-version.outputs.major }}"

          echo "âœ… Image and all tags signed successfully with keyless OIDC"
          echo "ðŸ“ Signatures uploaded to Rekor transparency log"

      - name: Generate release summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # PostgreSQL Single-Node Image Published :rocket:

          ## Image Details

          **Registry:** `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}`
          **Digest:** `${{ steps.build.outputs.digest }}`
          **PostgreSQL Version:** ${{ steps.actual-version.outputs.full }} (verified from image)
          **Build Timestamp:** ${{ steps.timestamp.outputs.value }}
          **Build Type:** single-node

          ## Tags Published

          - `${{ steps.tags.outputs.versioned }}` (primary)
          - `${{ steps.pg-version.outputs.full }}-single-node`
          - `${{ steps.pg-version.outputs.major }}-single-node`
          - `${{ steps.pg-version.outputs.full }}`
          - `${{ steps.pg-version.outputs.major }}`

          ## Pull Commands

          ```bash
          # Full versioned tag (recommended for production)
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tags.outputs.versioned }}

          # By digest (immutable)
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}

          # Convenience tags (may change)
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.pg-version.outputs.full }}-single-node
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.pg-version.outputs.major }}-single-node
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.pg-version.outputs.full }}
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.pg-version.outputs.major }}
          ```

          ## Extensions

          - **Total catalog entries:** 38
          - **Enabled extensions:** 36
          - **Disabled extensions:** 2 (pgq, supautils)
          - **Preloaded by default:** 4 (auto_explain module, pg_cron, pg_stat_statements, pgaudit)
          - **Auto-created extensions:** 6 (pg_cron, pg_stat_statements, pg_trgm, pgaudit, plpgsql, vector)
          - **PGDG packages:** 14 pre-compiled extensions
          - **Compiled from source:** 17 extensions (PGXS, cargo-pgrx, autotools, cmake, meson)

          ## Platforms

          - linux/amd64
          - linux/arm64

          ## Verification

          ```bash
          # Verify PostgreSQL version
          docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tags.outputs.versioned }} psql --version

          # Test basic functionality
          docker run -d --name pg-test \
            -e POSTGRES_PASSWORD=test \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tags.outputs.versioned }}

          # Wait for startup
          sleep 10

          # Check extensions
          docker exec pg-test psql -U postgres -c "SELECT extname FROM pg_available_extensions ORDER BY extname;"

          # Cleanup
          docker rm -f pg-test
          ```

          ## Deployment

          Update your compose file or Kubernetes manifests:

          ```yaml
          # Docker Compose
          services:
            postgres:
              image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tags.outputs.versioned }}
              # ... other config
          ```

          ```yaml
          # Kubernetes
          spec:
            containers:
            - name: postgres
              image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tags.outputs.versioned }}
              # ... other config
          ```

          ## Signature Verification

          This image is signed with Cosign using keyless OIDC. Verify the signature before deploying:

          ```bash
          # Install Cosign (if not already installed)
          # macOS: brew install cosign
          # Linux: https://docs.sigstore.dev/cosign/installation/
          # Windows: https://docs.sigstore.dev/cosign/installation/

          # Verify signature (keyless OIDC)
          cosign verify \
            --certificate-identity-regexp="^https://github.com/${{ github.repository }}/" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tags.outputs.versioned }}

          # Verify specific tag
          cosign verify \
            --certificate-identity-regexp="^https://github.com/${{ github.repository }}/" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.pg-version.outputs.major }}-single-node

          # Verify by digest (immutable reference)
          cosign verify \
            --certificate-identity-regexp="^https://github.com/${{ github.repository }}/" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
          ```

          **Expected output:** Certificate subject matches the GitHub Actions workflow identity.

          **Transparency Log:** All signatures are recorded in the Rekor public transparency log.

          ```bash
          # Search Rekor for this image
          rekor-cli search --artifact ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tags.outputs.versioned }}
          ```

          ## Supply Chain Verification

          View SBOM and provenance attestations:

          ```bash
          # View SBOM
          cosign download sbom ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tags.outputs.versioned }}

          # View provenance
          cosign download attestation \
            --predicate-type=https://slsa.dev/provenance/v0.2 \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tags.outputs.versioned }}
          ```
          EOF

      - name: Verify published image
        run: |
          echo "Pulling published image for verification..."
          for i in {1..3}; do
            if docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}; then
              echo "âœ… Published image pulled successfully"
              break
            else
              echo "âš ï¸ Pull attempt $i failed, retrying in $((i * 5)) seconds..."
              sleep $((i * 5))
              if [ $i -eq 3 ]; then
                echo "âŒ Failed to pull published image after 3 attempts"
                exit 1
              fi
            fi
          done

          echo "Verifying PostgreSQL version..."
          docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }} psql --version

          echo "Verifying image architecture..."
          docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }} uname -m

          echo "âœ… Image verification successful"

      - name: Test published image (amd64)
        timeout-minutes: 5
        run: |
          set -euo pipefail

          echo "Testing amd64 image..."
          docker run -d --platform linux/amd64 \
            --name pg-publish-test-amd64 \
            -e POSTGRES_PASSWORD=test \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}

          echo "Waiting for PostgreSQL to start..."
          for i in {1..30}; do
            if docker exec pg-publish-test-amd64 pg_isready -U postgres > /dev/null 2>&1; then
              echo "âœ… PostgreSQL ready"
              break
            fi
            sleep 2
          done

          echo "Testing extensions..."
          docker exec pg-publish-test-amd64 psql -U postgres -c "CREATE EXTENSION vector;"
          docker exec pg-publish-test-amd64 psql -U postgres -c "SELECT '[1,2,3]'::vector;"
          docker exec pg-publish-test-amd64 psql -U postgres -c "CREATE EXTENSION pg_cron;"
          docker exec pg-publish-test-amd64 psql -U postgres -c "CREATE EXTENSION pg_jsonschema;"

          echo "Testing auto-config..."
          docker logs pg-publish-test-amd64 2>&1 | grep -i "detected ram" || echo "RAM detection log"
          docker exec pg-publish-test-amd64 psql -U postgres -c "SHOW shared_buffers;"
          docker exec pg-publish-test-amd64 psql -U postgres -c "SHOW max_connections;"

          docker rm -f pg-publish-test-amd64
          echo "âœ… amd64 image test passed"

      - name: Test published image (arm64)
        timeout-minutes: 5
        run: |
          set -euo pipefail

          echo "Testing arm64 image..."
          docker run -d --platform linux/arm64 \
            --name pg-publish-test-arm64 \
            -e POSTGRES_PASSWORD=test \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}

          echo "Waiting for PostgreSQL to start (arm64 on QEMU may be slower)..."
          for i in {1..60}; do
            if docker exec pg-publish-test-arm64 pg_isready -U postgres > /dev/null 2>&1; then
              echo "âœ… PostgreSQL ready"
              break
            fi
            sleep 2
          done

          echo "Testing compiled extensions on arm64..."
          docker exec pg-publish-test-arm64 psql -U postgres -c "CREATE EXTENSION vector;"
          docker exec pg-publish-test-arm64 psql -U postgres -c "SELECT '[1,2,3]'::vector;"
          docker exec pg-publish-test-arm64 psql -U postgres -c "CREATE EXTENSION pg_jsonschema;"

          docker rm -f pg-publish-test-arm64
          echo "âœ… arm64 image test passed"

      - name: Cache Trivy vulnerability database
        uses: actions/cache@v4
        with:
          path: .trivy-cache
          key: trivy-db-${{ runner.os }}-${{ hashFiles('.github/workflows/publish.yml') }}
          restore-keys: |
            trivy-db-${{ runner.os }}-

      - name: Best practices scan (Dockle)
        uses: erzz/dockle-action@v1
        with:
          image: "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}"
          exit-code: "1"
          failure-threshold: WARN
          accept-keywords: key
          accept-filenames: /docker-entrypoint-initdb.d

      - name: Security scan (SARIF for GitHub Security)
        uses: aquasecurity/trivy-action@0.33.1
        env:
          TRIVY_CACHE_DIR: .trivy-cache
        with:
          image-ref: "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}"
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH"

      - name: Upload Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        if: always() && hashFiles('trivy-results.sarif') != ''
        with:
          sarif_file: "trivy-results.sarif"

      - name: Security scan (blocking on failures)
        uses: aquasecurity/trivy-action@0.33.1
        env:
          TRIVY_CACHE_DIR: .trivy-cache
        with:
          image-ref: "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}"
          format: "table"
          severity: "CRITICAL,HIGH"
          exit-code: "1" # Fail on CRITICAL/HIGH vulnerabilities

      - name: Promote testing image to production tags
        run: |
          echo "âœ… All security scans passed. Promoting testing image to production tags..."

          # Use docker buildx imagetools to create production tags
          # This points new tags to the same manifest digest (no re-push needed)
          docker buildx imagetools create \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:testing-${{ github.sha }} \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tags.outputs.versioned }} \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.pg-version.outputs.full }}-single-node \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.pg-version.outputs.major }}-single-node \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.pg-version.outputs.full }} \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.pg-version.outputs.major }}

          echo "âœ… Production tags created successfully"
          echo "Primary tag: ${{ steps.tags.outputs.versioned }}"
          echo "Digest: ${{ steps.build.outputs.digest }}"

      - name: Publish release notes
        run: |
          echo "Published single-node PostgreSQL image to ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          echo "Primary tag: ${{ steps.tags.outputs.versioned }}"
          echo "Digest: ${{ steps.build.outputs.digest }}"
          echo "Platforms: linux/amd64, linux/arm64"
