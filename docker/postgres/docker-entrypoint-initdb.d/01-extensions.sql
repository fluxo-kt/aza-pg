-- PostgreSQL initialization: enable baseline extensions with state tracking
-- Runs automatically on first cluster start.
-- Generated by scripts/config-generator/generator.ts from extensions.manifest.json
--
-- DO NOT EDIT MANUALLY - Changes will be overwritten
-- Edit docker/postgres/extensions.manifest.json and regenerate
-- Create initialization status tracking table
-- This table serves as the contract between initialization and healthcheck
-- Healthcheck queries this table instead of hardcoding extension lists
CREATE TABLE IF NOT EXISTS pg_aza_status (
  id SERIAL PRIMARY KEY,
  init_timestamp TIMESTAMPTZ DEFAULT now(),
  script_version TEXT NOT NULL,
  expected_extensions TEXT[] NOT NULL,
  created_extensions TEXT[] DEFAULT ARRAY[]::TEXT[],
  failed_extensions TEXT[] DEFAULT ARRAY[]::TEXT[],
  status TEXT NOT NULL CHECK (
    status IN ('in_progress', 'completed', 'failed', 'partial')
  ),
  error_details TEXT,
  notes TEXT
);

-- Index for efficient healthcheck queries (latest status)
CREATE INDEX IF NOT EXISTS idx_pg_aza_status_timestamp ON pg_aza_status (init_timestamp DESC);

DO $$
DECLARE
    v_status_id INTEGER;
    v_expected_exts TEXT[] := ARRAY['pg_cron', 'pg_stat_monitor', 'pg_stat_statements', 'pg_trgm', 'pgaudit', 'pgmq', 'plpgsql', 'timescaledb', 'vector', 'vectorscale'];
    v_created_exts TEXT[] := ARRAY[]::TEXT[];
    v_failed_exts TEXT[] := ARRAY[]::TEXT[];
    v_error_msg TEXT;
BEGIN
    -- Record initialization start
    INSERT INTO pg_aza_status (script_version, expected_extensions, status, notes)
    VALUES ('2025-11-23', v_expected_exts, 'in_progress', 'Baseline extension initialization started')
    RETURNING id INTO v_status_id;

    -- Attempt to create each extension with error handling

    -- pg_cron (operations)
    BEGIN
        CREATE EXTENSION IF NOT EXISTS "pg_cron";
        v_created_exts := array_append(v_created_exts, 'pg_cron');
        RAISE NOTICE 'Created extension: pg_cron';
    EXCEPTION WHEN OTHERS THEN
        v_failed_exts := array_append(v_failed_exts, 'pg_cron');
        GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
        RAISE WARNING 'Failed to create extension pg_cron: %', v_error_msg;
    END;

    -- pg_stat_monitor (observability)
    BEGIN
        CREATE EXTENSION IF NOT EXISTS "pg_stat_monitor";
        v_created_exts := array_append(v_created_exts, 'pg_stat_monitor');
        RAISE NOTICE 'Created extension: pg_stat_monitor';
    EXCEPTION WHEN OTHERS THEN
        v_failed_exts := array_append(v_failed_exts, 'pg_stat_monitor');
        GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
        RAISE WARNING 'Failed to create extension pg_stat_monitor: %', v_error_msg;
    END;

    -- pg_stat_statements (observability)
    BEGIN
        CREATE EXTENSION IF NOT EXISTS "pg_stat_statements";
        v_created_exts := array_append(v_created_exts, 'pg_stat_statements');
        RAISE NOTICE 'Created extension: pg_stat_statements';
    EXCEPTION WHEN OTHERS THEN
        v_failed_exts := array_append(v_failed_exts, 'pg_stat_statements');
        GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
        RAISE WARNING 'Failed to create extension pg_stat_statements: %', v_error_msg;
    END;

    -- pg_trgm (search)
    BEGIN
        CREATE EXTENSION IF NOT EXISTS "pg_trgm";
        v_created_exts := array_append(v_created_exts, 'pg_trgm');
        RAISE NOTICE 'Created extension: pg_trgm';
    EXCEPTION WHEN OTHERS THEN
        v_failed_exts := array_append(v_failed_exts, 'pg_trgm');
        GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
        RAISE WARNING 'Failed to create extension pg_trgm: %', v_error_msg;
    END;

    -- pgaudit (security)
    BEGIN
        CREATE EXTENSION IF NOT EXISTS "pgaudit";
        v_created_exts := array_append(v_created_exts, 'pgaudit');
        RAISE NOTICE 'Created extension: pgaudit';
    EXCEPTION WHEN OTHERS THEN
        v_failed_exts := array_append(v_failed_exts, 'pgaudit');
        GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
        RAISE WARNING 'Failed to create extension pgaudit: %', v_error_msg;
    END;

    -- pgmq (queueing)
    BEGIN
        CREATE EXTENSION IF NOT EXISTS "pgmq";
        v_created_exts := array_append(v_created_exts, 'pgmq');
        RAISE NOTICE 'Created extension: pgmq';
    EXCEPTION WHEN OTHERS THEN
        v_failed_exts := array_append(v_failed_exts, 'pgmq');
        GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
        RAISE WARNING 'Failed to create extension pgmq: %', v_error_msg;
    END;

    -- plpgsql (language)
    BEGIN
        CREATE EXTENSION IF NOT EXISTS "plpgsql";
        v_created_exts := array_append(v_created_exts, 'plpgsql');
        RAISE NOTICE 'Created extension: plpgsql';
    EXCEPTION WHEN OTHERS THEN
        v_failed_exts := array_append(v_failed_exts, 'plpgsql');
        GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
        RAISE WARNING 'Failed to create extension plpgsql: %', v_error_msg;
    END;

    -- timescaledb (timeseries)
    BEGIN
        CREATE EXTENSION IF NOT EXISTS "timescaledb";
        v_created_exts := array_append(v_created_exts, 'timescaledb');
        RAISE NOTICE 'Created extension: timescaledb';
    EXCEPTION WHEN OTHERS THEN
        v_failed_exts := array_append(v_failed_exts, 'timescaledb');
        GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
        RAISE WARNING 'Failed to create extension timescaledb: %', v_error_msg;
    END;

    -- pgvector (ai)
    BEGIN
        CREATE EXTENSION IF NOT EXISTS "vector";
        v_created_exts := array_append(v_created_exts, 'vector');
        RAISE NOTICE 'Created extension: vector';
    EXCEPTION WHEN OTHERS THEN
        v_failed_exts := array_append(v_failed_exts, 'vector');
        GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
        RAISE WARNING 'Failed to create extension vector: %', v_error_msg;
    END;

    -- pgvectorscale (ai)
    BEGIN
        CREATE EXTENSION IF NOT EXISTS "vectorscale";
        v_created_exts := array_append(v_created_exts, 'vectorscale');
        RAISE NOTICE 'Created extension: vectorscale';
    EXCEPTION WHEN OTHERS THEN
        v_failed_exts := array_append(v_failed_exts, 'vectorscale');
        GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
        RAISE WARNING 'Failed to create extension vectorscale: %', v_error_msg;
    END;

    -- Update initialization status based on results
    UPDATE pg_aza_status
    SET
        created_extensions = v_created_exts,
        failed_extensions = v_failed_exts,
        status = CASE
            WHEN array_length(v_failed_exts, 1) IS NULL THEN 'completed'
            WHEN array_length(v_created_exts, 1) > 0 THEN 'partial'
            ELSE 'failed'
        END,
        notes = CASE
            WHEN array_length(v_failed_exts, 1) IS NULL THEN
                'All 10 baseline extensions created successfully'
            ELSE
                'Initialization completed with ' || array_length(v_failed_exts, 1)::TEXT || ' failure(s)'
        END
    WHERE id = v_status_id;

    -- Log final status
    IF array_length(v_failed_exts, 1) IS NULL THEN
        RAISE NOTICE 'Baseline extensions enabled (pg_cron, pg_stat_monitor, pg_stat_statements, pg_trgm, pgaudit, pgmq, plpgsql, timescaledb, vector, vectorscale). Additional extensions are available but disabled by default.';
    ELSE
        RAISE WARNING 'Initialization completed with failures. Created: %, Failed: %', v_created_exts, v_failed_exts;
    END IF;
END;
$$;