#!/usr/bin/env bun

import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import type { StackType, PostgreSQLSettings } from './types.js';
import { BASE_CONFIG } from './base-config.js';

const REPO_ROOT = join(import.meta.dir, '../..');

function mergeSettings(
  common: PostgreSQLSettings,
  stackOverrides: Partial<PostgreSQLSettings>
): PostgreSQLSettings {
  return { ...common, ...stackOverrides };
}

function formatSetting(key: string, value: any): string {
  if (value === undefined) return '';

  if (key === 'sharedPreloadLibraries') {
    return `shared_preload_libraries = '${(value as string[]).join(',')}'`;
  }

  let snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();

  // Convert extension settings to proper format (dot notation)
  snakeKey = snakeKey.replace(/^pg_stat_statements_/, 'pg_stat_statements.');
  snakeKey = snakeKey.replace(/^auto_explain_/, 'auto_explain.');
  snakeKey = snakeKey.replace(/^pg_audit_/, 'pgaudit.');
  snakeKey = snakeKey.replace(/^cron_/, 'cron.');

  if (typeof value === 'boolean') {
    return `${snakeKey} = ${value ? 'on' : 'off'}`;
  }

  if (typeof value === 'number') {
    return `${snakeKey} = ${value}`;
  }

  return `${snakeKey} = '${value}'`;
}

function generatePostgresqlConf(stack: StackType, settings: PostgreSQLSettings): string {
  const lines: string[] = [];

  lines.push('# PostgreSQL Configuration');
  lines.push(`# Stack: ${stack}`);
  lines.push('# Generated by scripts/config-generator/generator.ts');
  lines.push('#');
  lines.push('# DO NOT EDIT MANUALLY - Changes will be overwritten');
  lines.push('# Edit scripts/config-generator/base-config.ts and regenerate');
  lines.push('');
  lines.push('# Base Configuration');
  lines.push("include = '/etc/postgresql/postgresql-base.conf'");
  lines.push('');

  const categories = {
    connection: ['listenAddresses', 'port', 'sharedPreloadLibraries', 'idleSessionTimeout'],
    io: ['ioMethod', 'ioCombineLimit'],
    logging: [
      'logDestination', 'loggingCollector', 'logMinDurationStatement', 'logLinePrefix',
      'logLockWaits', 'logTempFiles', 'logTimezone', 'logCheckpoints', 'logConnections',
      'logDisconnections', 'logAutovacuumMinDuration', 'logReplicationCommands'
    ],
    locale: ['timezone', 'lcMessages', 'lcMonetary', 'lcNumeric', 'lcTime', 'defaultTextSearchConfig'],
    pg_stat_statements: ['pgStatStatementsMax', 'pgStatStatementsTrack'],
    auto_explain: [
      'autoExplainLogMinDuration', 'autoExplainLogAnalyze', 'autoExplainLogBuffers',
      'autoExplainLogNestedStatements', 'autoExplainLogTiming'
    ],
    autovacuum: [
      'autovacuum', 'autovacuumNaptime', 'autovacuumVacuumCostDelay',
      'autovacuumVacuumCostLimit', 'autovacuumVacuumScaleFactor',
      'autovacuumAnalyzeScaleFactor', 'autovacuumFreezeMaxAge'
    ],
    checkpoints: ['checkpointCompletionTarget'],
    wal: [
      'walLevel', 'walCompression', 'maxWalSize', 'minWalSize',
      'maxWalSenders', 'walKeepSize', 'archiveMode', 'archiveCommand'
    ],
    replication: [
      'synchronousCommit', 'synchronousStandbyNames', 'maxReplicationSlots',
      'idleReplicationSlotTimeout', 'walSenderTimeout', 'hotStandby',
      'maxStandbyArchiveDelay', 'maxStandbyStreamingDelay', 'hotStandbyFeedback',
      'walReceiverStatusInterval'
    ],
    pg_cron: ['cronDatabaseName', 'cronLogRun', 'cronLogStatement'],
    pgaudit: ['pgAuditLog', 'pgAuditLogStatementOnce', 'pgAuditLogLevel', 'pgAuditLogRelation'],
  };

  const includeCategories: Record<StackType, string[]> = {
    single: ['wal', 'pgaudit'],
    primary: ['replication', 'wal', 'pg_cron', 'pgaudit'],
    replica: ['replication', 'wal', 'pgaudit'],
  };

  for (const cat of includeCategories[stack]) {
    const categoryKeys = categories[cat as keyof typeof categories];
    const categoryLines: string[] = [];

    for (const key of categoryKeys) {
      const value = settings[key as keyof PostgreSQLSettings];
      if (value !== undefined) {
        const formatted = formatSetting(key, value);
        if (formatted) {
          categoryLines.push(formatted);
        }
      }
    }

    if (categoryLines.length > 0) {
      lines.push(`# ${cat.replace(/_/g, ' ').toUpperCase()}`);
      lines.push(...categoryLines);
      lines.push('');
    }
  }

  if (stack === 'replica' || stack === 'single') {
    if (settings.autoExplainLogTiming !== undefined) {
      lines.push('# AUTO EXPLAIN');
      lines.push(formatSetting('autoExplainLogTiming', settings.autoExplainLogTiming));
      lines.push('');
    }
  }

  if (stack === 'primary' && settings.archiveMode === 'off') {
    lines.push('# WAL Archiving (disabled by default)');
    lines.push('# Uncomment and configure for Point-in-Time Recovery (PITR):');
    lines.push("# archive_mode = 'on'");
    lines.push("# archive_command = 'cp %p /backup/wal/%f'");
    lines.push('');
  }

  lines.push('# Runtime auto-configuration');
  lines.push('# The following settings are overridden at container startup:');
  lines.push('# - shared_buffers, effective_cache_size, maintenance_work_mem, work_mem');
  lines.push('# - max_connections, max_worker_processes, max_parallel_workers');
  lines.push('# Set POSTGRES_SKIP_AUTOCONFIG=true to disable');

  return lines.join('\n');
}

function generateBaseConf(settings: PostgreSQLSettings): string {
  const lines: string[] = [];

  lines.push('# PostgreSQL 18 Base Configuration');
  lines.push('# ============================================');
  lines.push('# Shared settings across all aza-pg deployments (primary, replica, single).');
  lines.push('# Generated by scripts/config-generator/generator.ts');
  lines.push('#');
  lines.push('# DO NOT EDIT MANUALLY - Changes will be overwritten');
  lines.push('# Edit scripts/config-generator/base-config.ts and regenerate');
  lines.push('');

  const categories = {
    connection: ['listenAddresses', 'sharedPreloadLibraries'],
    io: ['ioMethod', 'ioCombineLimit'],
    logging: [
      'logDestination', 'loggingCollector', 'logMinDurationStatement', 'logLinePrefix',
      'logLockWaits', 'logTempFiles', 'logCheckpoints', 'logConnections',
      'logDisconnections', 'logAutovacuumMinDuration'
    ],
    locale: ['timezone', 'logTimezone', 'lcMessages', 'lcMonetary', 'lcNumeric', 'lcTime', 'defaultTextSearchConfig'],
    pg_stat_statements: ['pgStatStatementsMax', 'pgStatStatementsTrack'],
    auto_explain: [
      'autoExplainLogMinDuration', 'autoExplainLogAnalyze', 'autoExplainLogBuffers',
      'autoExplainLogNestedStatements'
    ],
    autovacuum: [
      'autovacuum', 'autovacuumNaptime', 'autovacuumVacuumCostDelay',
      'autovacuumVacuumCostLimit', 'autovacuumVacuumScaleFactor',
      'autovacuumAnalyzeScaleFactor', 'autovacuumFreezeMaxAge'
    ],
    checkpoints: ['checkpointCompletionTarget'],
    wal: ['walLevel', 'walCompression'],
  };

  for (const [catName, categoryKeys] of Object.entries(categories)) {
    const categoryLines: string[] = [];

    for (const key of categoryKeys) {
      const value = settings[key as keyof PostgreSQLSettings];
      if (value !== undefined) {
        const formatted = formatSetting(key, value);
        if (formatted) {
          categoryLines.push(formatted);
        }
      }
    }

    if (categoryLines.length > 0) {
      lines.push(`# ${catName.replace(/_/g, ' ').toUpperCase()}`);
      lines.push(...categoryLines);
      lines.push('');
    }
  }

  return lines.join('\n');
}

function generatePgHba(stack: StackType): string {
  const lines: string[] = [];

  lines.push('# PostgreSQL Client Authentication Configuration');
  lines.push(`# Stack: ${stack}`);
  lines.push('# Generated by scripts/config-generator/generator.ts');
  lines.push('#');
  lines.push('# DO NOT EDIT MANUALLY - Changes will be overwritten');
  lines.push('# Edit scripts/config-generator/base-config.ts and regenerate');
  lines.push('');
  lines.push('# TYPE  DATABASE        USER            ADDRESS                 METHOD');
  lines.push('');

  for (const rule of BASE_CONFIG.pgHbaRules) {
    if (rule.stackSpecific && !rule.stackSpecific.includes(stack)) {
      continue;
    }

    if (rule.comment) {
      lines.push(`# ${rule.comment}`);
    }

    const parts = [rule.type, rule.database, rule.user];

    if (rule.address) {
      parts.push(rule.address.padEnd(24));
    }

    parts.push(rule.method);

    lines.push(parts.join('\t'));
  }

  return lines.join('\n');
}

function generateConfigs() {
  console.log('üîß Generating PostgreSQL configurations...\n');

  // Generate base config
  console.log('üìù Generating base configuration...');
  const baseConf = generateBaseConf(BASE_CONFIG.common);
  const baseConfPath = join(REPO_ROOT, 'docker/postgres/configs/postgresql-base.conf');
  writeFileSync(baseConfPath, baseConf);
  console.log(`   ‚úì ${baseConfPath}`);

  // Generate stack-specific configs
  const stacks: StackType[] = ['primary', 'replica', 'single'];

  for (const stack of stacks) {
    console.log(`\nüìù Generating ${stack} stack configurations...`);

    const settings = mergeSettings(BASE_CONFIG.common, BASE_CONFIG.stacks[stack]);
    const postgresqlConf = generatePostgresqlConf(stack, settings);

    let confDir: string;
    let confName: string;

    if (stack === 'single') {
      confDir = join(REPO_ROOT, 'stacks/single/configs');
      confName = 'postgresql.conf';
    } else {
      confDir = join(REPO_ROOT, `stacks/${stack}/configs`);
      confName = `postgresql-${stack}.conf`;
    }

    mkdirSync(confDir, { recursive: true });

    const postgresqlConfPath = join(confDir, confName);
    writeFileSync(postgresqlConfPath, postgresqlConf);
    console.log(`   ‚úì ${postgresqlConfPath}`);

    const pgHbaConf = generatePgHba(stack);
    const pgHbaPath = join(confDir, 'pg_hba.conf');
    writeFileSync(pgHbaPath, pgHbaConf);
    console.log(`   ‚úì ${pgHbaPath}`);
  }

  console.log('\n‚úÖ Configuration generation complete!\n');
  console.log('üìã Generated files:');
  console.log('   - docker/postgres/configs/postgresql-base.conf');
  console.log('   - stacks/primary/configs/postgresql-primary.conf');
  console.log('   - stacks/primary/configs/pg_hba.conf');
  console.log('   - stacks/replica/configs/postgresql-replica.conf');
  console.log('   - stacks/replica/configs/pg_hba.conf');
  console.log('   - stacks/single/configs/postgresql.conf');
  console.log('   - stacks/single/configs/pg_hba.conf');
  console.log('');
}

generateConfigs();
