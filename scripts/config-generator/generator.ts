#!/usr/bin/env bun

import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import type { StackType, PostgreSQLSettings } from './types.js';
import { BASE_CONFIG } from './base-config.js';

const SHARED_CATEGORY_FIELDS = {
  io: ['ioMethod', 'ioCombineLimit'] as const,
  pg_stat_statements: ['pgStatStatementsMax', 'pgStatStatementsTrack'] as const,
  autovacuum: [
    'autovacuum',
    'autovacuumNaptime',
    'autovacuumVacuumCostDelay',
    'autovacuumVacuumCostLimit',
    'autovacuumVacuumScaleFactor',
    'autovacuumAnalyzeScaleFactor',
    'autovacuumFreezeMaxAge',
  ] as const,
  checkpoints: ['checkpointCompletionTarget'] as const,
};

const REPO_ROOT = join(import.meta.dir, '../..');

function mergeSettings(
  common: PostgreSQLSettings,
  stackOverrides: Partial<PostgreSQLSettings>
): PostgreSQLSettings {
  return { ...common, ...stackOverrides };
}

/**
 * Convert camelCase to snake_case using proper regex patterns
 * Handles consecutive capitals and acronyms correctly
 */
function camelToSnakeCase(str: string): string {
  return str
    // Insert underscore between lowercase and uppercase: camelCase -> camel_Case
    .replace(/([a-z0-9])([A-Z])/g, '$1_$2')
    // Insert underscore between consecutive capitals and lowercase: XMLParser -> XML_Parser
    .replace(/([A-Z])([A-Z][a-z])/g, '$1_$2')
    // Convert to lowercase
    .toLowerCase();
}

/**
 * Map of PostgreSQL-specific naming patterns that require dot notation
 * Key: snake_case prefix (e.g., "pg_stat_statements")
 * Value: PostgreSQL namespace (e.g., "pg_stat_statements")
 */
const PG_EXTENSION_NAMESPACES: Record<string, string> = {
  'pg_stat_statements': 'pg_stat_statements',
  'auto_explain': 'auto_explain',
  'pg_audit': 'pgaudit',  // Note: pgaudit uses lowercase namespace
  'cron': 'cron',
  'timescaledb': 'timescaledb',
};

/**
 * Convert a configuration key to proper PostgreSQL GUC (Grand Unified Configuration) format
 * Handles extension namespaces with dot notation (e.g., pg_stat_statements.max)
 */
function toPostgresGUCName(camelCaseKey: string): string {
  const snakeKey = camelToSnakeCase(camelCaseKey);

  // Check if this key belongs to an extension namespace
  for (const [prefix, namespace] of Object.entries(PG_EXTENSION_NAMESPACES)) {
    if (snakeKey.startsWith(`${prefix}_`)) {
      // Extract the setting name after the prefix
      const settingName = snakeKey.slice(prefix.length + 1);
      return `${namespace}.${settingName}`;
    }
  }

  // Validate PostgreSQL GUC naming rules
  // Must start with letter or underscore, contain only lowercase letters, digits, underscores, and dots
  if (!snakeKey.match(/^[a-z_][a-z0-9_.]*$/)) {
    throw new Error(
      `Invalid PostgreSQL GUC name generated: "${snakeKey}" (from camelCase: "${camelCaseKey}"). ` +
      `GUC names must start with a letter or underscore and contain only lowercase letters, digits, underscores, and dots.`
    );
  }

  return snakeKey;
}

/**
 * Format a configuration value for PostgreSQL
 * Handles booleans (on/off), numbers, strings, and arrays
 */
function formatValue(value: any): string {
  if (typeof value === 'boolean') {
    return value ? 'on' : 'off';
  }

  if (typeof value === 'number') {
    return String(value);
  }

  if (Array.isArray(value)) {
    return `'${value.join(',')}'`;
  }

  // String values get quoted
  return `'${value}'`;
}

/**
 * Format a single configuration setting as a PostgreSQL GUC line
 * Returns empty string for undefined values
 */
function formatSetting(key: string, value: any): string {
  if (value === undefined) return '';

  // Special case: sharedPreloadLibraries has a custom comment in configs
  // Handle it specially to maintain existing behavior
  if (key === 'sharedPreloadLibraries') {
    if (Array.isArray(value) && value.length === 0) {
      // Empty array means runtime-controlled, don't emit
      return '';
    }
    return `shared_preload_libraries = ${formatValue(value)}`;
  }

  const pgKey = toPostgresGUCName(key);
  return `${pgKey} = ${formatValue(value)}`;
}

function generatePostgresqlConf(
  stack: StackType,
  settings: PostgreSQLSettings,
  overrides: Partial<PostgreSQLSettings>
): string {
  const lines: string[] = [];

  lines.push('# PostgreSQL Configuration');
  lines.push(`# Stack: ${stack}`);
  lines.push('# Generated by scripts/config-generator/generator.ts');
  lines.push('#');
  lines.push('# DO NOT EDIT MANUALLY - Changes will be overwritten');
  lines.push('# Edit scripts/config-generator/base-config.ts and regenerate');
  lines.push('');
  lines.push('# Base Configuration');
  lines.push("include = '/etc/postgresql/postgresql-base.conf'");
  lines.push('');

  const categories = {
    connection: ['listenAddresses', 'port', 'sharedPreloadLibraries', 'idleSessionTimeout'],
    io: [...SHARED_CATEGORY_FIELDS.io],
    logging: [
      'logDestination', 'loggingCollector', 'logMinDurationStatement', 'logLinePrefix',
      'logLockWaits', 'logTempFiles', 'logTimezone', 'logCheckpoints', 'logConnections',
      'logDisconnections', 'logAutovacuumMinDuration', 'logReplicationCommands'
    ],
    locale: ['timezone', 'lcMessages', 'lcMonetary', 'lcNumeric', 'lcTime', 'defaultTextSearchConfig'],
    pg_stat_statements: [...SHARED_CATEGORY_FIELDS.pg_stat_statements],
    auto_explain: [
      'autoExplainLogMinDuration', 'autoExplainLogAnalyze', 'autoExplainLogBuffers',
      'autoExplainLogNestedStatements', 'autoExplainLogTiming'
    ],
    autovacuum: [...SHARED_CATEGORY_FIELDS.autovacuum],
    checkpoints: [...SHARED_CATEGORY_FIELDS.checkpoints],
    wal: [
      'walLevel', 'walCompression', 'maxWalSize', 'minWalSize',
      'maxWalSenders', 'walKeepSize', 'archiveMode', 'archiveCommand'
    ],
    replication: [
      'synchronousCommit', 'synchronousStandbyNames', 'maxReplicationSlots',
      'idleReplicationSlotTimeout', 'walSenderTimeout', 'hotStandby',
      'maxStandbyArchiveDelay', 'maxStandbyStreamingDelay', 'hotStandbyFeedback',
      'walReceiverStatusInterval', 'logReplicationCommands'
    ],
    pg_cron: ['cronDatabaseName', 'cronLogRun', 'cronLogStatement'],
    pgaudit: ['pgAuditLog', 'pgAuditLogStatementOnce', 'pgAuditLogLevel', 'pgAuditLogRelation'],
  };

  const includeCategories: Record<StackType, string[]> = {
    single: ['wal', 'pgaudit'],
    primary: ['replication', 'wal', 'pg_cron', 'pgaudit'],
    replica: ['replication', 'wal', 'pg_cron', 'pgaudit'],
  };

  for (const cat of includeCategories[stack]) {
    const categoryKeys = categories[cat as keyof typeof categories];
    const categoryLines: string[] = [];

    for (const key of categoryKeys) {
      if (overrides[key as keyof PostgreSQLSettings] === undefined) {
        continue;
      }

      const value = settings[key as keyof PostgreSQLSettings];
      if (value !== undefined) {
        const formatted = formatSetting(key, value);
        if (formatted) {
          categoryLines.push(formatted);
        }
      }
    }

    if (categoryLines.length > 0) {
      lines.push(`# ${cat.replace(/_/g, ' ').toUpperCase()}`);
      lines.push(...categoryLines);
      lines.push('');
    }
  }

  if (stack === 'replica' || stack === 'single') {
    if (overrides.autoExplainLogTiming !== undefined) {
      lines.push('# AUTO EXPLAIN');
      lines.push(formatSetting('autoExplainLogTiming', settings.autoExplainLogTiming));
      lines.push('');
    }
  }

  if (stack === 'primary' && overrides.archiveMode !== undefined && settings.archiveMode === 'off') {
    lines.push('# WAL Archiving (disabled by default)');
    lines.push('# Uncomment and configure for Point-in-Time Recovery (PITR):');
    lines.push("# archive_mode = 'on'");
    lines.push("# archive_command = 'cp %p /backup/wal/%f'");
    lines.push('');
  }

  lines.push('# Runtime auto-configuration');
  lines.push('# The following settings are overridden at container startup:');
  lines.push('# - Memory: shared_buffers, effective_cache_size, maintenance_work_mem, work_mem');
  lines.push('# - Connections: max_connections, max_worker_processes, max_parallel_workers');
  lines.push('# - Extensions: shared_preload_libraries (default: pg_stat_statements,auto_explain,pg_cron,pgaudit)');
  lines.push('# Auto-config is always enabled and cannot be disabled.');

  return lines.join('\n');
}

function generateBaseConf(settings: PostgreSQLSettings): string {
  const lines: string[] = [];

  lines.push('# PostgreSQL 18 Base Configuration');
  lines.push('# ============================================');
  lines.push('# Shared settings across all aza-pg deployments (primary, replica, single).');
  lines.push('# Generated by scripts/config-generator/generator.ts');
  lines.push('#');
  lines.push('# DO NOT EDIT MANUALLY - Changes will be overwritten');
  lines.push('# Edit scripts/config-generator/base-config.ts and regenerate');
  lines.push('');

  const categories = {
    connection: ['listenAddresses', 'sharedPreloadLibraries'],
    io: [...SHARED_CATEGORY_FIELDS.io],
    logging: [
      'logDestination', 'loggingCollector', 'logMinDurationStatement', 'logLinePrefix',
      'logLockWaits', 'logTempFiles', 'logCheckpoints', 'logConnections',
      'logDisconnections', 'logAutovacuumMinDuration'
    ],
    locale: ['timezone', 'logTimezone', 'lcMessages', 'lcMonetary', 'lcNumeric', 'lcTime', 'defaultTextSearchConfig'],
    pg_stat_statements: [...SHARED_CATEGORY_FIELDS.pg_stat_statements],
    auto_explain: [
      'autoExplainLogMinDuration', 'autoExplainLogAnalyze', 'autoExplainLogBuffers',
      'autoExplainLogNestedStatements'
    ],
    autovacuum: [...SHARED_CATEGORY_FIELDS.autovacuum],
    checkpoints: [...SHARED_CATEGORY_FIELDS.checkpoints],
    query_planner: ['randomPageCost', 'effectiveIoConcurrency'],
    wal: ['walLevel', 'walCompression', 'maxWalSize', 'minWalSize'],
    timescaledb: ['timescaledbTelemetryLevel'],
  };

  for (const [catName, categoryKeys] of Object.entries(categories)) {
    const categoryLines: string[] = [];

    for (const key of categoryKeys) {
      const value = settings[key as keyof PostgreSQLSettings];
      if (value !== undefined) {
        const formatted = formatSetting(key, value);
        if (formatted) {
          categoryLines.push(formatted);
        }
      }
    }

    // Always emit the CONNECTION section, even if empty, to add the shared_preload_libraries comment
    if (catName === 'connection') {
      lines.push('# CONNECTION');
      if (categoryLines.length > 0) {
        lines.push(...categoryLines);
      } else {
        // No settings to emit, but still add listen_addresses if present
        const listenValue = settings.listenAddresses;
        if (listenValue !== undefined) {
          lines.push(formatSetting('listenAddresses', listenValue));
        }
      }
      // Add comment about sharedPreloadLibraries being runtime-controlled
      lines.push('# NOTE: shared_preload_libraries is intentionally OMITTED.');
      lines.push("# It's controlled at runtime by docker-auto-config-entrypoint.sh via -c flag.");
      lines.push('# Command-line -c flags override config file settings, so we must not set it here.');
      lines.push('');
    } else if (categoryLines.length > 0) {
      lines.push(`# ${catName.replace(/_/g, ' ').toUpperCase()}`);
      lines.push(...categoryLines);
      lines.push('');
    }
  }

  return lines.join('\n');
}

function generatePgHba(stack: StackType): string {
  const lines: string[] = [];

  lines.push('# PostgreSQL Client Authentication Configuration');
  lines.push(`# Stack: ${stack}`);
  lines.push('# Generated by scripts/config-generator/generator.ts');
  lines.push('#');
  lines.push('# DO NOT EDIT MANUALLY - Changes will be overwritten');
  lines.push('# Edit scripts/config-generator/base-config.ts and regenerate');
  lines.push('');
  lines.push('# TYPE  DATABASE        USER            ADDRESS                 METHOD');
  lines.push('');

  for (const rule of BASE_CONFIG.pgHbaRules) {
    if (rule.stackSpecific && !rule.stackSpecific.includes(stack)) {
      continue;
    }

    if (rule.comment) {
      lines.push(`# ${rule.comment}`);
    }

    const parts = [rule.type, rule.database, rule.user];

    if (rule.address) {
      parts.push(rule.address.padEnd(24));
    }

    parts.push(rule.method);

    lines.push(parts.join('\t'));
  }

  return lines.join('\n');
}

function generateConfigs() {
  console.log('üîß Generating PostgreSQL configurations...\n');

  try {
    // Generate base config
    console.log('üìù Generating base configuration...');
    const baseConf = generateBaseConf(BASE_CONFIG.common);
    const baseConfPath = join(REPO_ROOT, 'docker/postgres/configs/postgresql-base.conf');

    try {
      writeFileSync(baseConfPath, baseConf);
      console.log(`   ‚úì ${baseConfPath}`);
    } catch (err) {
      const error = err as Error;
      throw new Error(`Failed to write base config to ${baseConfPath}: ${error.message}`);
    }

    // Generate stack-specific configs
    const stacks: StackType[] = ['primary', 'replica', 'single'];

    for (const stack of stacks) {
      console.log(`\nüìù Generating ${stack} stack configurations...`);

      const stackOverrides = BASE_CONFIG.stacks[stack];
      const settings = mergeSettings(BASE_CONFIG.common, stackOverrides);
      const postgresqlConf = generatePostgresqlConf(stack, settings, stackOverrides);

      let confDir: string;
      let confName: string;

      if (stack === 'single') {
        confDir = join(REPO_ROOT, 'stacks/single/configs');
        confName = 'postgresql.conf';
      } else {
        confDir = join(REPO_ROOT, `stacks/${stack}/configs`);
        confName = `postgresql-${stack}.conf`;
      }

      try {
        mkdirSync(confDir, { recursive: true });
      } catch (err) {
        const error = err as Error;
        throw new Error(`Failed to create directory ${confDir}: ${error.message}`);
      }

      const postgresqlConfPath = join(confDir, confName);
      try {
        writeFileSync(postgresqlConfPath, postgresqlConf);
        console.log(`   ‚úì ${postgresqlConfPath}`);
      } catch (err) {
        const error = err as Error;
        throw new Error(`Failed to write ${stack} postgresql config to ${postgresqlConfPath}: ${error.message}`);
      }

      const pgHbaConf = generatePgHba(stack);
      const pgHbaPath = join(confDir, 'pg_hba.conf');
      try {
        writeFileSync(pgHbaPath, pgHbaConf);
        console.log(`   ‚úì ${pgHbaPath}`);
      } catch (err) {
        const error = err as Error;
        throw new Error(`Failed to write pg_hba.conf to ${pgHbaPath}: ${error.message}`);
      }
    }
  } catch (err) {
    const error = err as Error;
    console.error(`\n‚ùå Configuration generation failed: ${error.message}`);
    process.exit(1);
  }

  console.log('\n‚úÖ Configuration generation complete!\n');
  console.log('üìã Generated files:');
  console.log('   - docker/postgres/configs/postgresql-base.conf');
  console.log('   - stacks/primary/configs/postgresql-primary.conf');
  console.log('   - stacks/primary/configs/pg_hba.conf');
  console.log('   - stacks/replica/configs/postgresql-replica.conf');
  console.log('   - stacks/replica/configs/pg_hba.conf');
  console.log('   - stacks/single/configs/postgresql.conf');
  console.log('   - stacks/single/configs/pg_hba.conf');
  console.log('');
}

generateConfigs();
