#!/usr/bin/env bun

import { writeFileSync, mkdirSync, readFileSync } from "fs";
import { join } from "path";
import type { StackType, PostgreSQLSettings } from "./types.js";
import { BASE_CONFIG } from "./base-config.js";
import { formatSetting } from "../utils/guc-formatter.js";

const SHARED_CATEGORY_FIELDS = {
  io: ["ioMethod", "ioCombineLimit"] as const,
  pg_stat_statements: ["pgStatStatementsMax", "pgStatStatementsTrack"] as const,
  autovacuum: [
    "autovacuum",
    "autovacuumNaptime",
    "autovacuumVacuumCostDelay",
    "autovacuumVacuumCostLimit",
    "autovacuumVacuumScaleFactor",
    "autovacuumAnalyzeScaleFactor",
    "autovacuumFreezeMaxAge",
  ] as const,
  checkpoints: ["checkpointCompletionTarget"] as const,
};

const REPO_ROOT = join(import.meta.dir, "../..");

function mergeSettings(
  common: PostgreSQLSettings,
  stackOverrides: Partial<PostgreSQLSettings>
): PostgreSQLSettings {
  return { ...common, ...stackOverrides };
}

function generatePostgresqlConf(
  stack: StackType,
  settings: PostgreSQLSettings,
  overrides: Partial<PostgreSQLSettings>
): string {
  const lines: string[] = [];

  lines.push("# PostgreSQL Configuration");
  lines.push(`# Stack: ${stack}`);
  lines.push("# Generated by scripts/config-generator/generator.ts");
  lines.push("#");
  lines.push("# DO NOT EDIT MANUALLY - Changes will be overwritten");
  lines.push("# Edit scripts/config-generator/base-config.ts and regenerate");
  lines.push("");
  lines.push("# Base Configuration");
  lines.push("include = '/etc/postgresql/postgresql-base.conf'");
  lines.push("");

  const categories = {
    connection: ["listenAddresses", "port", "sharedPreloadLibraries", "idleSessionTimeout"],
    io: [...SHARED_CATEGORY_FIELDS.io],
    logging: [
      "logDestination",
      "loggingCollector",
      "logMinDurationStatement",
      "logLinePrefix",
      "logLockWaits",
      "logTempFiles",
      "logTimezone",
      "logCheckpoints",
      "logConnections",
      "logDisconnections",
      "logAutovacuumMinDuration",
      "logReplicationCommands",
    ],
    locale: [
      "timezone",
      "lcMessages",
      "lcMonetary",
      "lcNumeric",
      "lcTime",
      "defaultTextSearchConfig",
    ],
    pg_stat_statements: [...SHARED_CATEGORY_FIELDS.pg_stat_statements],
    auto_explain: [
      "autoExplainLogMinDuration",
      "autoExplainLogAnalyze",
      "autoExplainLogBuffers",
      "autoExplainLogNestedStatements",
      "autoExplainLogTiming",
    ],
    autovacuum: [...SHARED_CATEGORY_FIELDS.autovacuum],
    checkpoints: [...SHARED_CATEGORY_FIELDS.checkpoints],
    wal: [
      "walLevel",
      "walCompression",
      "maxWalSize",
      "minWalSize",
      "maxWalSenders",
      "walKeepSize",
      "archiveMode",
      "archiveCommand",
    ],
    replication: [
      "synchronousCommit",
      "synchronousStandbyNames",
      "maxReplicationSlots",
      "idleReplicationSlotTimeout",
      "walSenderTimeout",
      "hotStandby",
      "maxStandbyArchiveDelay",
      "maxStandbyStreamingDelay",
      "hotStandbyFeedback",
      "walReceiverStatusInterval",
      "logReplicationCommands",
    ],
    pg_cron: ["cronDatabaseName", "cronLogRun", "cronLogStatement"],
    pgaudit: ["pgAuditLog", "pgAuditLogStatementOnce", "pgAuditLogLevel", "pgAuditLogRelation"],
  };

  const includeCategories: Record<StackType, string[]> = {
    single: ["wal", "pgaudit"],
    primary: ["replication", "wal", "pg_cron", "pgaudit"],
    replica: ["replication", "wal", "pg_cron", "pgaudit"],
  };

  for (const cat of includeCategories[stack]) {
    const categoryKeys = categories[cat as keyof typeof categories];
    const categoryLines: string[] = [];

    for (const key of categoryKeys) {
      if (overrides[key as keyof PostgreSQLSettings] === undefined) {
        continue;
      }

      const value = settings[key as keyof PostgreSQLSettings];
      if (value !== undefined) {
        const formatted = formatSetting(key, value);
        if (formatted) {
          categoryLines.push(formatted);
        }
      }
    }

    if (categoryLines.length > 0) {
      lines.push(`# ${cat.replace(/_/g, " ").toUpperCase()}`);
      lines.push(...categoryLines);
      lines.push("");
    }
  }

  if (stack === "replica" || stack === "single") {
    if (overrides.autoExplainLogTiming !== undefined) {
      lines.push("# AUTO EXPLAIN");
      lines.push(formatSetting("autoExplainLogTiming", settings.autoExplainLogTiming));
      lines.push("");
    }
  }

  if (
    stack === "primary" &&
    overrides.archiveMode !== undefined &&
    settings.archiveMode === "off"
  ) {
    lines.push("# WAL Archiving (disabled by default)");
    lines.push("# Uncomment and configure for Point-in-Time Recovery (PITR):");
    lines.push("# archive_mode = 'on'");
    lines.push("# archive_command = 'cp %p /backup/wal/%f'");
    lines.push("");
  }

  lines.push("# Runtime auto-configuration");
  lines.push("# The following settings are overridden at container startup:");
  lines.push("# - Memory: shared_buffers, effective_cache_size, maintenance_work_mem, work_mem");
  lines.push("# - Connections: max_connections, max_worker_processes, max_parallel_workers");
  lines.push(
    "# - Extensions: shared_preload_libraries (default: pg_stat_statements,auto_explain,pg_cron,pgaudit)"
  );
  lines.push("# Auto-config is always enabled and cannot be disabled.");

  return lines.join("\n");
}

function generateBaseConf(settings: PostgreSQLSettings): string {
  const lines: string[] = [];

  lines.push("# PostgreSQL 18 Base Configuration");
  lines.push("# ============================================");
  lines.push("# Shared settings across all aza-pg deployments (primary, replica, single).");
  lines.push("# Generated by scripts/config-generator/generator.ts");
  lines.push("#");
  lines.push("# DO NOT EDIT MANUALLY - Changes will be overwritten");
  lines.push("# Edit scripts/config-generator/base-config.ts and regenerate");
  lines.push("");

  const categories = {
    connection: ["listenAddresses", "sharedPreloadLibraries"],
    io: [...SHARED_CATEGORY_FIELDS.io],
    logging: [
      "logDestination",
      "loggingCollector",
      "logMinDurationStatement",
      "logLinePrefix",
      "logLockWaits",
      "logTempFiles",
      "logCheckpoints",
      "logConnections",
      "logDisconnections",
      "logAutovacuumMinDuration",
    ],
    locale: [
      "timezone",
      "logTimezone",
      "lcMessages",
      "lcMonetary",
      "lcNumeric",
      "lcTime",
      "defaultTextSearchConfig",
    ],
    pg_stat_statements: [...SHARED_CATEGORY_FIELDS.pg_stat_statements],
    auto_explain: [
      "autoExplainLogMinDuration",
      "autoExplainLogAnalyze",
      "autoExplainLogBuffers",
      "autoExplainLogNestedStatements",
    ],
    autovacuum: [...SHARED_CATEGORY_FIELDS.autovacuum],
    checkpoints: [...SHARED_CATEGORY_FIELDS.checkpoints],
    query_planner: ["randomPageCost", "effectiveIoConcurrency"],
    wal: ["walLevel", "walCompression", "maxWalSize", "minWalSize"],
    timescaledb: ["timescaledbTelemetryLevel"],
  };

  for (const [catName, categoryKeys] of Object.entries(categories)) {
    const categoryLines: string[] = [];

    for (const key of categoryKeys) {
      const value = settings[key as keyof PostgreSQLSettings];
      if (value !== undefined) {
        const formatted = formatSetting(key, value);
        if (formatted) {
          categoryLines.push(formatted);
        }
      }
    }

    // Always emit the CONNECTION section, even if empty, to add the shared_preload_libraries comment
    if (catName === "connection") {
      lines.push("# CONNECTION");
      if (categoryLines.length > 0) {
        lines.push(...categoryLines);
      } else {
        // No settings to emit, but still add listen_addresses if present
        const listenValue = settings.listenAddresses;
        if (listenValue !== undefined) {
          lines.push(formatSetting("listenAddresses", listenValue));
        }
      }
      // Add comment about sharedPreloadLibraries being runtime-controlled
      lines.push("# NOTE: shared_preload_libraries is intentionally OMITTED.");
      lines.push("# It's controlled at runtime by docker-auto-config-entrypoint.sh via -c flag.");
      lines.push(
        "# Command-line -c flags override config file settings, so we must not set it here."
      );
      lines.push("");
    } else if (categoryLines.length > 0) {
      lines.push(`# ${catName.replace(/_/g, " ").toUpperCase()}`);
      lines.push(...categoryLines);
      lines.push("");
    }
  }

  return lines.join("\n");
}

function generatePgHba(stack: StackType): string {
  const lines: string[] = [];

  lines.push("# PostgreSQL Client Authentication Configuration");
  lines.push(`# Stack: ${stack}`);
  lines.push("# Generated by scripts/config-generator/generator.ts");
  lines.push("#");
  lines.push("# DO NOT EDIT MANUALLY - Changes will be overwritten");
  lines.push("# Edit scripts/config-generator/base-config.ts and regenerate");
  lines.push("");
  lines.push("# TYPE  DATABASE        USER            ADDRESS                 METHOD");
  lines.push("");

  for (const rule of BASE_CONFIG.pgHbaRules) {
    if (rule.stackSpecific && !rule.stackSpecific.includes(stack)) {
      continue;
    }

    if (rule.comment) {
      lines.push(`# ${rule.comment}`);
    }

    const parts = [rule.type, rule.database, rule.user];

    if (rule.address) {
      parts.push(rule.address.padEnd(24));
    }

    parts.push(rule.method);

    lines.push(parts.join("\t"));
  }

  return lines.join("\n");
}

/**
 * Generate 01-extensions.sql init script from manifest
 * Only includes extensions with enabled=true AND runtime.defaultEnable=true
 */
function generateExtensionsInitScript(): string {
  const manifestPath = join(REPO_ROOT, "docker/postgres/extensions.manifest.json");
  const manifestJson = readFileSync(manifestPath, "utf-8");
  const manifest = JSON.parse(manifestJson);

  // Filter for extensions to enable by default
  const extensionsToEnable = manifest.entries.filter((entry: any) => {
    const enabled = entry.enabled ?? true; // Default to true for backward compatibility
    const defaultEnable = entry.runtime?.defaultEnable ?? false;
    const kind = entry.kind;

    // Only enable if:
    // 1. Extension is enabled in manifest (not disabled)
    // 2. Extension has runtime.defaultEnable = true
    // 3. Extension is not a "tool" (tools don't support CREATE EXTENSION)
    return enabled && defaultEnable && kind !== "tool";
  });

  const lines: string[] = [];
  lines.push("-- PostgreSQL initialization: enable baseline extensions");
  lines.push("-- Runs automatically on first cluster start.");
  lines.push("-- Generated by scripts/config-generator/generator.ts from extensions.manifest.json");
  lines.push("--");
  lines.push("-- DO NOT EDIT MANUALLY - Changes will be overwritten");
  lines.push("-- Edit docker/postgres/extensions.manifest.json and regenerate");
  lines.push("");

  if (extensionsToEnable.length > 0) {
    lines.push("-- Core extensions pre-enabled by default.");
    for (const entry of extensionsToEnable) {
      const displayName = entry.displayName || entry.name;
      const category = entry.category || "misc";
      lines.push(`CREATE EXTENSION IF NOT EXISTS ${entry.name}; -- ${displayName} (${category})`);
    }
  } else {
    lines.push("-- No extensions enabled by default.");
    lines.push(
      "-- All extensions are available but must be created manually via CREATE EXTENSION."
    );
  }

  lines.push("");
  lines.push("DO $$");
  lines.push("BEGIN");

  const extensionNames = extensionsToEnable.map((e: any) => e.name).join(", ");
  if (extensionNames) {
    lines.push(
      `  RAISE NOTICE 'Baseline extensions enabled (${extensionNames}). Additional extensions are available but disabled by default.';`
    );
  } else {
    lines.push(
      `  RAISE NOTICE 'No baseline extensions enabled. All extensions available but must be created manually.';`
    );
  }

  lines.push("END;");
  lines.push("$$;");
  lines.push("");

  return lines.join("\n");
}

function generateConfigs() {
  console.log("üîß Generating PostgreSQL configurations...\n");

  try {
    // Generate base config
    console.log("üìù Generating base configuration...");
    const baseConf = generateBaseConf(BASE_CONFIG.common);
    const baseConfPath = join(REPO_ROOT, "docker/postgres/configs/postgresql-base.conf");

    try {
      writeFileSync(baseConfPath, baseConf);
      console.log(`   ‚úì ${baseConfPath}`);
    } catch (err) {
      const error = err as Error;
      throw new Error(`Failed to write base config to ${baseConfPath}: ${error.message}`);
    }

    // Generate stack-specific configs
    const stacks: StackType[] = ["primary", "replica", "single"];

    for (const stack of stacks) {
      console.log(`\nüìù Generating ${stack} stack configurations...`);

      const stackOverrides = BASE_CONFIG.stacks[stack];
      const settings = mergeSettings(BASE_CONFIG.common, stackOverrides);
      const postgresqlConf = generatePostgresqlConf(stack, settings, stackOverrides);

      let confDir: string;
      let confName: string;

      if (stack === "single") {
        confDir = join(REPO_ROOT, "stacks/single/configs");
        confName = "postgresql.conf";
      } else {
        confDir = join(REPO_ROOT, `stacks/${stack}/configs`);
        confName = `postgresql-${stack}.conf`;
      }

      try {
        mkdirSync(confDir, { recursive: true });
      } catch (err) {
        const error = err as Error;
        throw new Error(`Failed to create directory ${confDir}: ${error.message}`);
      }

      const postgresqlConfPath = join(confDir, confName);
      try {
        writeFileSync(postgresqlConfPath, postgresqlConf);
        console.log(`   ‚úì ${postgresqlConfPath}`);
      } catch (err) {
        const error = err as Error;
        throw new Error(
          `Failed to write ${stack} postgresql config to ${postgresqlConfPath}: ${error.message}`
        );
      }

      const pgHbaConf = generatePgHba(stack);
      const pgHbaPath = join(confDir, "pg_hba.conf");
      try {
        writeFileSync(pgHbaPath, pgHbaConf);
        console.log(`   ‚úì ${pgHbaPath}`);
      } catch (err) {
        const error = err as Error;
        throw new Error(`Failed to write pg_hba.conf to ${pgHbaPath}: ${error.message}`);
      }
    }

    // Generate 01-extensions.sql init script
    console.log("\nüìù Generating extension init script...");
    const extensionsInitScript = generateExtensionsInitScript();
    const extensionsInitPath = join(
      REPO_ROOT,
      "docker/postgres/docker-entrypoint-initdb.d/01-extensions.sql"
    );
    try {
      writeFileSync(extensionsInitPath, extensionsInitScript);
      console.log(`   ‚úì ${extensionsInitPath}`);
    } catch (err) {
      const error = err as Error;
      throw new Error(
        `Failed to write extensions init script to ${extensionsInitPath}: ${error.message}`
      );
    }
  } catch (err) {
    const error = err as Error;
    console.error(`\n‚ùå Configuration generation failed: ${error.message}`);
    process.exit(1);
  }

  console.log("\n‚úÖ Configuration generation complete!\n");
  console.log("üìã Generated files:");
  console.log("   - docker/postgres/configs/postgresql-base.conf");
  console.log("   - stacks/primary/configs/postgresql-primary.conf");
  console.log("   - stacks/primary/configs/pg_hba.conf");
  console.log("   - stacks/replica/configs/postgresql-replica.conf");
  console.log("   - stacks/replica/configs/pg_hba.conf");
  console.log("   - stacks/single/configs/postgresql.conf");
  console.log("   - stacks/single/configs/pg_hba.conf");
  console.log("   - docker/postgres/docker-entrypoint-initdb.d/01-extensions.sql");
  console.log("");
}

generateConfigs();
