#!/usr/bin/env bun

import { join } from "node:path";
import type { StackType, PostgreSQLSettings } from "./types";
import { BASE_CONFIG } from "./base-config";
import { formatSetting } from "../utils/guc-formatter";
import { loadManifest, getDefaultEnabledExtensions } from "./manifest-loader";
import { generateExtensionsInitScript } from "./sql-generator";
import { writeConfigFile, writeConfigWithDir } from "./config-writer";
import { success, info, error } from "../utils/logger";

const SHARED_CATEGORY_FIELDS = {
  io: ["ioMethod", "ioCombineLimit"] as const,
  pg_stat_statements: ["pgStatStatementsMax", "pgStatStatementsTrack"] as const,
  autovacuum: [
    "autovacuum",
    "autovacuumNaptime",
    "autovacuumVacuumCostDelay",
    "autovacuumVacuumCostLimit",
    "autovacuumVacuumScaleFactor",
    "autovacuumAnalyzeScaleFactor",
    "autovacuumFreezeMaxAge",
  ] as const,
  checkpoints: ["checkpointCompletionTarget"] as const,
};

const REPO_ROOT = join(import.meta.dir, "../..");

function mergeSettings(
  common: PostgreSQLSettings,
  stackOverrides: Partial<PostgreSQLSettings>
): PostgreSQLSettings {
  return { ...common, ...stackOverrides };
}

function generatePostgresqlConf(
  stack: StackType,
  settings: PostgreSQLSettings,
  overrides: Partial<PostgreSQLSettings>
): string {
  const lines: string[] = [];

  lines.push("# PostgreSQL Configuration");
  lines.push(`# Stack: ${stack}`);
  lines.push("# Generated by scripts/config-generator/generator.ts");
  lines.push("#");
  lines.push("# DO NOT EDIT MANUALLY - Changes will be overwritten");
  lines.push("# Edit scripts/config-generator/base-config.ts and regenerate");
  lines.push("");
  lines.push("# Base Configuration");
  lines.push("include = '/etc/postgresql/postgresql-base.conf'");
  lines.push("");

  const categories = {
    connection: ["listenAddresses", "port", "sharedPreloadLibraries", "idleSessionTimeout"],
    io: [...SHARED_CATEGORY_FIELDS.io],
    logging: [
      "logDestination",
      "loggingCollector",
      "logMinDurationStatement",
      "logLinePrefix",
      "logLockWaits",
      "logTempFiles",
      "logTimezone",
      "logCheckpoints",
      "logConnections",
      "logDisconnections",
      "logAutovacuumMinDuration",
      "logReplicationCommands",
    ],
    locale: [
      "timezone",
      "lcMessages",
      "lcMonetary",
      "lcNumeric",
      "lcTime",
      "defaultTextSearchConfig",
    ],
    pg_stat_statements: [...SHARED_CATEGORY_FIELDS.pg_stat_statements],
    auto_explain: [
      "autoExplainLogMinDuration",
      "autoExplainLogAnalyze",
      "autoExplainLogBuffers",
      "autoExplainLogNestedStatements",
      "autoExplainLogTiming",
    ],
    autovacuum: [...SHARED_CATEGORY_FIELDS.autovacuum],
    checkpoints: [...SHARED_CATEGORY_FIELDS.checkpoints],
    wal: [
      "walLevel",
      "walCompression",
      "maxWalSize",
      "minWalSize",
      "maxWalSenders",
      "walKeepSize",
      "archiveMode",
      "archiveCommand",
    ],
    replication: [
      "synchronousCommit",
      "synchronousStandbyNames",
      "maxReplicationSlots",
      "idleReplicationSlotTimeout",
      "walSenderTimeout",
      "hotStandby",
      "maxStandbyArchiveDelay",
      "maxStandbyStreamingDelay",
      "hotStandbyFeedback",
      "walReceiverStatusInterval",
      "logReplicationCommands",
    ],
    pg_cron: ["cronDatabaseName", "cronLogRun", "cronLogStatement"],
    pgaudit: ["pgAuditLog", "pgAuditLogStatementOnce", "pgAuditLogLevel", "pgAuditLogRelation"],
  };

  const includeCategories: Record<StackType, string[]> = {
    single: ["wal", "pgaudit"],
    primary: ["replication", "wal", "pg_cron", "pgaudit"],
    replica: ["replication", "wal", "pg_cron", "pgaudit"],
  };

  for (const cat of includeCategories[stack]) {
    const categoryKeys = categories[cat as keyof typeof categories];
    const categoryLines: string[] = [];

    for (const key of categoryKeys) {
      if (overrides[key as keyof PostgreSQLSettings] === undefined) {
        continue;
      }

      const value = settings[key as keyof PostgreSQLSettings];
      if (value !== undefined) {
        const formatted = formatSetting(key, value);
        if (formatted) {
          categoryLines.push(formatted);
        }
      }
    }

    if (categoryLines.length > 0) {
      lines.push(`# ${cat.replace(/_/g, " ").toUpperCase()}`);
      lines.push(...categoryLines);
      lines.push("");
    }
  }

  if (stack === "replica" || stack === "single") {
    if (overrides.autoExplainLogTiming !== undefined) {
      lines.push("# AUTO EXPLAIN");
      lines.push(formatSetting("autoExplainLogTiming", settings.autoExplainLogTiming));
      lines.push("");
    }
  }

  if (
    stack === "primary" &&
    overrides.archiveMode !== undefined &&
    settings.archiveMode === "off"
  ) {
    lines.push("# WAL Archiving (disabled by default)");
    lines.push("# Uncomment and configure for Point-in-Time Recovery (PITR):");
    lines.push("# archive_mode = 'on'");
    lines.push("# archive_command = 'cp %p /backup/wal/%f'");
    lines.push("");
  }

  lines.push("# Runtime auto-configuration");
  lines.push("# The following settings are overridden at container startup:");
  lines.push("# - Memory: shared_buffers, effective_cache_size, maintenance_work_mem, work_mem");
  lines.push("# - Connections: max_connections, max_worker_processes, max_parallel_workers");
  lines.push(
    "# - Extensions: shared_preload_libraries (default: pg_stat_statements,auto_explain,pg_cron,pgaudit)"
  );
  lines.push("# Auto-config is always enabled and cannot be disabled.");

  return lines.join("\n");
}

function generateBaseConf(settings: PostgreSQLSettings): string {
  const lines: string[] = [];

  lines.push("# PostgreSQL 18 Base Configuration");
  lines.push("# ============================================");
  lines.push("# Shared settings across all aza-pg deployments (primary, replica, single).");
  lines.push("# Generated by scripts/config-generator/generator.ts");
  lines.push("#");
  lines.push("# DO NOT EDIT MANUALLY - Changes will be overwritten");
  lines.push("# Edit scripts/config-generator/base-config.ts and regenerate");
  lines.push("");

  const categories = {
    connection: ["listenAddresses", "sharedPreloadLibraries"],
    io: [...SHARED_CATEGORY_FIELDS.io],
    logging: [
      "logDestination",
      "loggingCollector",
      "logMinDurationStatement",
      "logLinePrefix",
      "logLockWaits",
      "logTempFiles",
      "logCheckpoints",
      "logConnections",
      "logDisconnections",
      "logAutovacuumMinDuration",
    ],
    locale: [
      "timezone",
      "logTimezone",
      "lcMessages",
      "lcMonetary",
      "lcNumeric",
      "lcTime",
      "defaultTextSearchConfig",
    ],
    pg_stat_statements: [...SHARED_CATEGORY_FIELDS.pg_stat_statements],
    auto_explain: [
      "autoExplainLogMinDuration",
      "autoExplainLogAnalyze",
      "autoExplainLogBuffers",
      "autoExplainLogNestedStatements",
    ],
    autovacuum: [...SHARED_CATEGORY_FIELDS.autovacuum],
    checkpoints: [...SHARED_CATEGORY_FIELDS.checkpoints],
    query_planner: ["randomPageCost", "effectiveIoConcurrency"],
    wal: ["walLevel", "walCompression", "maxWalSize", "minWalSize"],
    timescaledb: ["timescaledbTelemetryLevel"],
  };

  for (const [catName, categoryKeys] of Object.entries(categories)) {
    const categoryLines: string[] = [];

    for (const key of categoryKeys) {
      const value = settings[key as keyof PostgreSQLSettings];
      if (value !== undefined) {
        const formatted = formatSetting(key, value);
        if (formatted) {
          categoryLines.push(formatted);
        }
      }
    }

    // Always emit the CONNECTION section, even if empty, to add the shared_preload_libraries comment
    if (catName === "connection") {
      lines.push("# CONNECTION");
      if (categoryLines.length > 0) {
        lines.push(...categoryLines);
      } else {
        // No settings to emit, but still add listen_addresses if present
        const listenValue = settings.listenAddresses;
        if (listenValue !== undefined) {
          lines.push(formatSetting("listenAddresses", listenValue));
        }
      }
      // Add comment about sharedPreloadLibraries being runtime-controlled
      lines.push("# NOTE: shared_preload_libraries is intentionally OMITTED.");
      lines.push("# It's controlled at runtime by docker-auto-config-entrypoint.sh via -c flag.");
      lines.push(
        "# Command-line -c flags override config file settings, so we must not set it here."
      );
      lines.push("");
    } else if (categoryLines.length > 0) {
      lines.push(`# ${catName.replace(/_/g, " ").toUpperCase()}`);
      lines.push(...categoryLines);
      lines.push("");
    }
  }

  return lines.join("\n");
}

function generatePgHba(stack: StackType): string {
  const lines: string[] = [];

  lines.push("# PostgreSQL Client Authentication Configuration");
  lines.push(`# Stack: ${stack}`);
  lines.push("# Generated by scripts/config-generator/generator.ts");
  lines.push("#");
  lines.push("# DO NOT EDIT MANUALLY - Changes will be overwritten");
  lines.push("# Edit scripts/config-generator/base-config.ts and regenerate");
  lines.push("");
  lines.push("# TYPE  DATABASE        USER            ADDRESS                 METHOD");
  lines.push("");

  for (const rule of BASE_CONFIG.pgHbaRules) {
    if (rule.stackSpecific && !rule.stackSpecific.includes(stack)) {
      continue;
    }

    if (rule.comment) {
      lines.push(`# ${rule.comment}`);
    }

    const parts = [rule.type, rule.database, rule.user];

    if (rule.address) {
      parts.push(rule.address.padEnd(24));
    }

    parts.push(rule.method);

    lines.push(parts.join("\t"));
  }

  return lines.join("\n");
}

async function generateConfigs() {
  info("Generating PostgreSQL configurations...\n");

  try {
    // Generate base config
    info("Generating base configuration...");
    const baseConf = generateBaseConf(BASE_CONFIG.common);
    const baseConfPath = join(REPO_ROOT, "docker/postgres/configs/postgresql-base.conf");

    await writeConfigFile(baseConfPath, baseConf);
    console.log(`   ✓ ${baseConfPath}`);

    // Generate stack-specific configs
    const stacks: StackType[] = ["primary", "replica", "single"];

    for (const stack of stacks) {
      info(`Generating ${stack} stack configurations...`);

      const stackOverrides = BASE_CONFIG.stacks[stack];
      const settings = mergeSettings(BASE_CONFIG.common, stackOverrides);
      const postgresqlConf = generatePostgresqlConf(stack, settings, stackOverrides);

      let confDir: string;
      let confName: string;

      if (stack === "single") {
        confDir = join(REPO_ROOT, "stacks/single/configs");
        confName = "postgresql.conf";
      } else {
        confDir = join(REPO_ROOT, `stacks/${stack}/configs`);
        confName = `postgresql-${stack}.conf`;
      }

      const postgresqlConfPath = await writeConfigWithDir(confDir, confName, postgresqlConf);
      console.log(`   ✓ ${postgresqlConfPath}`);

      const pgHbaConf = generatePgHba(stack);
      const pgHbaPath = await writeConfigWithDir(confDir, "pg_hba.conf", pgHbaConf);
      console.log(`   ✓ ${pgHbaPath}`);
    }

    // Generate 01-extensions.sql init script
    info("Generating extension init script...");
    const manifest = await loadManifest(REPO_ROOT);
    const extensionsToEnable = getDefaultEnabledExtensions(manifest);
    const extensionsInitScript = generateExtensionsInitScript(extensionsToEnable);
    const extensionsInitPath = join(
      REPO_ROOT,
      "docker/postgres/docker-entrypoint-initdb.d/01-extensions.sql"
    );
    await writeConfigFile(extensionsInitPath, extensionsInitScript);
    console.log(`   ✓ ${extensionsInitPath}`);
  } catch (err) {
    const err_error = err as Error;
    error(`Configuration generation failed: ${err_error.message}`);
    process.exit(1);
  }

  success("Configuration generation complete!\n");
  info("Generated files:");
  console.log("   - docker/postgres/configs/postgresql-base.conf");
  console.log("   - stacks/primary/configs/postgresql-primary.conf");
  console.log("   - stacks/primary/configs/pg_hba.conf");
  console.log("   - stacks/replica/configs/postgresql-replica.conf");
  console.log("   - stacks/replica/configs/pg_hba.conf");
  console.log("   - stacks/single/configs/postgresql.conf");
  console.log("   - stacks/single/configs/pg_hba.conf");
  console.log("   - docker/postgres/docker-entrypoint-initdb.d/01-extensions.sql");
  console.log("");
}

generateConfigs();
