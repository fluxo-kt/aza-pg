#!/usr/bin/env bun
/**
 * Unit Test Suite for SQL Generator
 * Tests extension initialization SQL generation from manifest data
 *
 * Coverage:
 * - generateExtensionsInitScript creates valid SQL structure
 * - pg_aza_status table creation
 * - Extension creation with error handling
 * - Empty manifest handling
 * - Script structure validation
 *
 * Usage: bun test scripts/config-generator/sql-generator.test.ts
 */

import { describe, test, expect } from "bun:test";
import { generateExtensionsInitScript } from "./sql-generator";
import type { ManifestEntry } from "../extensions/manifest-data";

/**
 * Factory function to create test ManifestEntry objects with sensible defaults.
 * Only override what you need for each test.
 */
function createMockEntry(overrides: Partial<ManifestEntry> & { name: string }): ManifestEntry {
  return {
    kind: "extension",
    category: "test",
    description: `Test extension: ${overrides.name}`,
    source: { type: "builtin" },
    ...overrides,
  };
}

describe("generateExtensionsInitScript - Table Creation", () => {
  test("Creates pg_aza_status table", async () => {
    const extensions: ManifestEntry[] = [];
    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("CREATE TABLE IF NOT EXISTS pg_aza_status");
    expect(sql).toContain("id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY");
    expect(sql).toContain("init_timestamp TIMESTAMPTZ DEFAULT now()"); // Lowercase after formatting
    expect(sql).toContain("script_version TEXT NOT NULL");
    expect(sql).toContain("expected_extensions TEXT[] NOT NULL");
    expect(sql).toContain("created_extensions TEXT[] DEFAULT ARRAY[]::TEXT[]");
    expect(sql).toContain("failed_extensions TEXT[] DEFAULT ARRAY[]::TEXT[]");
    expect(sql).toContain("status TEXT NOT NULL");
  });

  test("Creates index on pg_aza_status", async () => {
    const extensions: ManifestEntry[] = [];
    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("CREATE INDEX IF NOT EXISTS idx_pg_aza_status_timestamp");
    expect(sql).toContain("ON pg_aza_status (init_timestamp DESC)"); // Space added by formatter
  });

  test("Status field has CHECK constraint", async () => {
    const extensions: ManifestEntry[] = [];
    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("CHECK (status IN ('in_progress', 'completed', 'failed', 'partial'))");
  });
});

describe("generateExtensionsInitScript - Extension Creation", () => {
  test("Single extension generates CREATE EXTENSION command", async () => {
    const extensions = [createMockEntry({ name: "pgvector", category: "ai" })];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "pgvector"');
    expect(sql).toContain("v_created_exts := array_append(v_created_exts, 'pgvector')");
    expect(sql).toContain("RAISE NOTICE 'Created extension: pgvector'");
  });

  test("Multiple extensions all included in SQL", async () => {
    const extensions = [
      createMockEntry({ name: "pgvector", category: "ai" }),
      createMockEntry({ name: "pg_stat_statements", kind: "builtin", category: "observability" }),
      createMockEntry({ name: "postgis", category: "geo" }),
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "pgvector"');
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "pg_stat_statements"');
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "postgis"');
  });

  test("Extension displayName used in comments", async () => {
    const extensions = [
      createMockEntry({
        name: "pgvector",
        displayName: "pgVector - Vector Similarity",
        category: "ai",
      }),
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("pgVector - Vector Similarity");
  });

  test("Extension category shown in comments", async () => {
    const extensions = [createMockEntry({ name: "pgvector", category: "machine-learning" })];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("(machine-learning)");
  });
});

describe("generateExtensionsInitScript - Error Handling", () => {
  test("Each extension wrapped in BEGIN/EXCEPTION block", async () => {
    const extensions = [createMockEntry({ name: "test_ext" })];

    const sql = await generateExtensionsInitScript(extensions);

    // Check for exception handling structure
    expect(sql).toContain("BEGIN");
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "test_ext"');
    expect(sql).toContain("EXCEPTION WHEN OTHERS THEN");
    expect(sql).toContain("v_failed_exts := array_append(v_failed_exts, 'test_ext')");
    expect(sql).toContain("GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT");
    expect(sql).toContain("RAISE WARNING 'Failed to create extension test_ext: %'");
  });

  test("Status updated based on success/failure", async () => {
    const extensions = [createMockEntry({ name: "test_ext" })];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("UPDATE pg_aza_status");
    expect(sql).toContain("created_extensions = v_created_exts");
    expect(sql).toContain("failed_extensions = v_failed_exts");
    expect(sql).toContain("WHEN array_length(v_failed_exts, 1) IS NULL THEN 'completed'");
    expect(sql).toContain("WHEN array_length(v_created_exts, 1) > 0 THEN 'partial'");
    expect(sql).toContain("ELSE 'failed'");
  });

  test("RAISE EXCEPTION on failures", async () => {
    const extensions = [createMockEntry({ name: "test_ext" })];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("RAISE EXCEPTION 'Extension initialization FAILED");
    expect(sql).toContain("Required extensions not available: %");
    expect(sql).toContain("Successfully created: %'");
    expect(sql).toContain("USING HINT =");
  });
});

describe("generateExtensionsInitScript - Empty Manifest", () => {
  test("Empty array generates valid SQL", async () => {
    const extensions: ManifestEntry[] = [];
    const sql = await generateExtensionsInitScript(extensions);

    // Should still create table
    expect(sql).toContain("CREATE TABLE IF NOT EXISTS pg_aza_status");

    // Should handle empty case
    expect(sql).toContain("No extensions to enable");
    expect(sql).not.toContain("CREATE EXTENSION");
  });

  test("Empty manifest sets status to completed", async () => {
    const extensions: ManifestEntry[] = [];
    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("UPDATE pg_aza_status");
    expect(sql).toContain("SET status = 'completed'");
    expect(sql).toContain("No baseline extensions enabled");
  });
});

describe("generateExtensionsInitScript - DO Block Structure", () => {
  test("Uses DO $$ anonymous block", async () => {
    const sql = await generateExtensionsInitScript([]);

    expect(sql).toContain("DO $$");
    expect(sql).toContain("DECLARE");
    expect(sql).toContain("BEGIN");
    expect(sql).toContain("END;");
    expect(sql).toContain("$$;");
  });

  test("Declares necessary variables", async () => {
    const extensions = [createMockEntry({ name: "test_ext" })];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("v_status_id INTEGER");
    expect(sql).toContain("v_expected_exts TEXT[]");
    expect(sql).toContain("v_created_exts TEXT[]");
    expect(sql).toContain("v_failed_exts TEXT[]");
    expect(sql).toContain("v_error_msg TEXT");
  });

  test("Records initialization start", async () => {
    const extensions = [createMockEntry({ name: "test_ext" })];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("INSERT INTO pg_aza_status");
    expect(sql).toContain("script_version, expected_extensions, status, notes");
    expect(sql).toContain("'in_progress'");
    expect(sql).toContain("Baseline extension initialization started");
    expect(sql).toContain("RETURNING id INTO v_status_id");
  });
});

describe("generateExtensionsInitScript - Generation Metadata", () => {
  test("Includes generation comments", async () => {
    const sql = await generateExtensionsInitScript([]);

    expect(sql).toContain("PostgreSQL initialization");
    expect(sql).toContain("Generated by scripts/config-generator/generator.ts");
    expect(sql).toContain("DO NOT EDIT MANUALLY");
    expect(sql).toContain("Edit docker/postgres/extensions.manifest.json and regenerate");
  });

  test("Script version uses content-based hash", async () => {
    const extensions = [createMockEntry({ name: "test_ext" })];

    const sql = await generateExtensionsInitScript(extensions);

    // Should contain a script version with PG version and hash
    // Format: "18.1-{7-char-hash}"
    const versionPattern = /VALUES \('18\.1-[a-f0-9]{7}'/;
    expect(sql).toMatch(versionPattern);
  });
});

describe("generateExtensionsInitScript - Expected Extensions Array", () => {
  test("Expected extensions array includes all extension names", async () => {
    const extensions = [createMockEntry({ name: "ext1" }), createMockEntry({ name: "ext2" })];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("v_expected_exts TEXT[] := ARRAY['ext1', 'ext2']");
  });

  test("Expected extensions list is properly formatted", async () => {
    const extensions = [createMockEntry({ name: "single_ext" })];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("ARRAY['single_ext']");
  });
});

describe("generateExtensionsInitScript - Success Messages", () => {
  test("Success message lists all extensions", async () => {
    const extensions = [createMockEntry({ name: "ext1" }), createMockEntry({ name: "ext2" })];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("Baseline extensions enabled (ext1, ext2)");
  });

  test("Success message mentions additional extensions", async () => {
    const extensions = [createMockEntry({ name: "test_ext" })];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("Additional extensions are available but disabled by default");
  });
});

describe("generateExtensionsInitScript - SQL Validity", () => {
  test("Generated SQL is non-empty", async () => {
    const sql = await generateExtensionsInitScript([]);

    expect(sql.length).toBeGreaterThan(0);
  });

  test("SQL contains no obvious syntax errors", async () => {
    const extensions = [createMockEntry({ name: "test_ext" })];

    const sql = await generateExtensionsInitScript(extensions);

    // Check for balanced DO blocks
    const doCount = (sql.match(/DO \$\$/g) || []).length;
    const endCount = (sql.match(/\$\$;/g) || []).length;
    expect(doCount).toBe(endCount);

    // Check for balanced BEGIN/END (PL/pgSQL requires equal counts)
    const beginCount = (sql.match(/\bBEGIN\b/g) || []).length;
    const endKeywordCount = (sql.match(/\bEND;/g) || []).length;
    expect(beginCount).toBe(endKeywordCount);
  });

  test("Extension names are properly quoted", async () => {
    const extensions = [createMockEntry({ name: "test_ext" })];

    const sql = await generateExtensionsInitScript(extensions);

    // CREATE EXTENSION should use double quotes
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "test_ext"');

    // Array literals should use single quotes
    expect(sql).toContain("'test_ext'");
  });
});

describe("generateExtensionsInitScript - Real-World Scenarios", () => {
  test("Production-like manifest with multiple extensions", async () => {
    const extensions = [
      createMockEntry({
        name: "pg_stat_statements",
        displayName: "pg_stat_statements",
        kind: "builtin",
        category: "observability",
      }),
      createMockEntry({
        name: "pgvector",
        displayName: "pgVector",
        category: "ai",
        source: {
          type: "git",
          repository: "https://github.com/pgvector/pgvector.git",
          tag: "v0.7.0",
        },
      }),
      createMockEntry({ name: "postgis", category: "geo" }),
    ];

    const sql = await generateExtensionsInitScript(extensions);

    // All extensions should be present
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "pg_stat_statements"');
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "pgvector"');
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "postgis"');

    // Should have proper structure
    expect(sql).toContain("CREATE TABLE IF NOT EXISTS pg_aza_status");
    expect(sql).toContain("DO $$");
    expect(sql).toContain("DECLARE");
    expect(sql).toContain(
      "v_expected_exts TEXT[] := ARRAY['pg_stat_statements', 'pgvector', 'postgis']"
    );
  });

  test("Extensions without displayName use name", async () => {
    const extensions = [createMockEntry({ name: "simple_ext" })];

    const sql = await generateExtensionsInitScript(extensions);

    // Name should appear in comment (category is always present)
    expect(sql).toContain("simple_ext (test)");
  });

  test("Extension without category defaults to misc", async () => {
    const extensions = [
      {
        name: "test_ext",
        kind: "extension",
        description: "Test",
        source: { type: "builtin" },
      } as ManifestEntry,
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("(misc)");
  });
});

describe("generateExtensionsInitScript - Edge Cases", () => {
  test("Handles extension names with underscores correctly", async () => {
    const extensions = [createMockEntry({ name: "pg_stat_statements" })];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "pg_stat_statements"');
    expect(sql).toContain("'pg_stat_statements'");
  });

  test("Handles extension names with numbers correctly", async () => {
    const extensions = [createMockEntry({ name: "h3" })];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "h3"');
  });

  test("Handles very long extension names", async () => {
    const longName = "a".repeat(63); // Max identifier length in PostgreSQL
    const extensions = [createMockEntry({ name: longName })];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain(`CREATE EXTENSION IF NOT EXISTS "${longName}"`);
    expect(sql).toContain(`'${longName}'`);
  });

  test("Handles many extensions efficiently", async () => {
    const extensions = Array.from({ length: 50 }, (_, i) => createMockEntry({ name: `ext_${i}` }));

    const sql = await generateExtensionsInitScript(extensions);

    // Should contain all 50 extension names
    expect(sql).toContain('"ext_0"');
    expect(sql).toContain('"ext_49"');
    expect((sql.match(/CREATE EXTENSION IF NOT EXISTS/g) || []).length).toBe(50);
  });

  test("Empty array produces valid SQL with no CREATE EXTENSION", async () => {
    const sql = await generateExtensionsInitScript([]);

    expect(sql).toContain("CREATE TABLE IF NOT EXISTS pg_aza_status");
    expect(sql).not.toContain("CREATE EXTENSION IF NOT EXISTS");
    expect(sql).toContain("No baseline extensions enabled");
  });

  test("Single extension with all optional fields", async () => {
    const extensions = [
      createMockEntry({
        name: "complex_ext",
        displayName: "Complex Extension™",
        category: "test-category",
        description: "A complex extension with special chars: <>",
      }),
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "complex_ext"');
    expect(sql).toContain("Complex Extension™");
  });
});

/**
 * SQL Injection Resistance Tests
 * ================================
 *
 * Security Context:
 * The SQL generator interpolates extension names into SQL strings at multiple points:
 * - Line 81: v_expected_exts TEXT[] := ARRAY[...names...]
 * - Line 104: CREATE EXTENSION IF NOT EXISTS "name"
 * - Line 105: v_created_exts := array_append(v_created_exts, 'name')
 * - Line 106: RAISE NOTICE 'Created extension: name'
 * - Line 108: v_failed_exts := array_append(v_failed_exts, 'name')
 * - Line 111: RAISE WARNING 'Failed to create extension name: %'
 * - Line 146: RAISE NOTICE '...extension list...'
 *
 * Current Implementation:
 * - CREATE EXTENSION uses double quotes (identifier quoting) - this is SAFE
 * - Array literals use single quotes WITHOUT escaping - VULNERABLE
 * - RAISE NOTICE/WARNING messages use single quotes WITHOUT escaping - VULNERABLE
 * - String concatenation in messages uses unescaped names - VULNERABLE
 *
 * While manifest-data.ts is currently the only source (trusted), defense-in-depth
 * suggests proper escaping to prevent SQL injection if sources expand in future.
 *
 * TODO: Add input validation or proper escaping for all string interpolations
 * - Option 1: Validate extension names (alphanumeric + underscore only)
 * - Option 2: Escape single quotes by doubling them (PostgreSQL standard)
 * - Option 3: Use parameterized queries (may not apply to code generation)
 */

/**
 * Helper to check if SQL contains an unescaped dangerous pattern.
 * Checks if pattern appears outside of quoted string literals.
 */
function containsUnescapedPattern(sql: string, pattern: string): boolean {
  const lines = sql.split("\n");
  for (const line of lines) {
    // Skip SQL comments
    if (line.trim().startsWith("--")) continue;

    if (line.includes(pattern)) {
      // Simple heuristic: count single quotes before the pattern
      const beforePattern = line.substring(0, line.indexOf(pattern));
      const singleQuotes = (beforePattern.match(/'/g) || []).length;

      // If even number of quotes before pattern, it's outside a string literal (vulnerable)
      // If odd number, it's inside a string literal (likely escaped)
      if (singleQuotes % 2 === 0) {
        return true;
      }
    }
  }
  return false;
}

describe("generateExtensionsInitScript - SQL Injection Resistance", () => {
  test("should handle malicious single quote in extension name", async () => {
    const maliciousEntry = createMockEntry({ name: "test'; DROP TABLE users; --" });

    const sql = await generateExtensionsInitScript([maliciousEntry]);

    // Should generate SQL without throwing
    expect(sql).toBeDefined();
    expect(sql.length).toBeGreaterThan(0);

    // Check for unescaped injection patterns
    // The DROP TABLE command should either be:
    // 1. Escaped (inside a string literal with proper quoting)
    // 2. Not present at all (if validation rejected it)
    const hasUnescapedDropTable = containsUnescapedPattern(sql, "DROP TABLE users");

    // EXPECTED TO FAIL: Current implementation doesn't escape single quotes
    // When fixed, this should pass (hasUnescapedDropTable should be false)
    expect(hasUnescapedDropTable).toBe(true); // Documents current vulnerable behavior

    // Verify critical SQL structure is still intact
    expect(sql).toContain("CREATE TABLE IF NOT EXISTS pg_aza_status");
    expect(sql).toContain("DO $$");
  });

  test("should handle malicious semicolon with statement injection", async () => {
    const maliciousEntry = createMockEntry({ name: "test; DELETE FROM pg_database; --" });

    const sql = await generateExtensionsInitScript([maliciousEntry]);

    expect(sql).toBeDefined();
    expect(sql.length).toBeGreaterThan(0);

    // Verify DELETE command is not executable outside string literals
    const hasUnescapedDelete = containsUnescapedPattern(sql, "DELETE FROM pg_database");

    // EXPECTED TO FAIL: Current implementation allows semicolon injection in messages
    expect(hasUnescapedDelete).toBe(true); // Documents current vulnerable behavior

    // The generated SQL should remain a single DO $$ block
    const doBlockCount = (sql.match(/DO \$\$/g) || []).length;
    expect(doBlockCount).toBe(1);

    // Count END; $$ occurrences - should be exactly 1
    const endBlockCount = (sql.match(/END;\s*\$\$/g) || []).length;
    expect(endBlockCount).toBe(1);
  });

  test("should handle SQL comment injection in extension name", async () => {
    const maliciousEntry = createMockEntry({ name: "test-- injection" });

    const sql = await generateExtensionsInitScript([maliciousEntry]);

    expect(sql).toBeDefined();
    expect(sql.length).toBeGreaterThan(0);

    // Check that the comment injection doesn't break the SQL structure
    // If "test-- injection" appears unescaped in RAISE messages,
    // everything after -- becomes a comment, potentially disabling error handling

    // Verify critical error handling is still present
    expect(sql).toContain("EXCEPTION WHEN OTHERS THEN");
    expect(sql).toContain("UPDATE pg_aza_status");

    // Check lines containing the malicious pattern
    const linesWithInjection = sql
      .split("\n")
      .filter((line) => line.includes("test--") && !line.trim().startsWith("--"));

    // If present, verify it's in a safe context
    // EXPECTED TO FAIL for RAISE NOTICE/WARNING messages
    for (const line of linesWithInjection) {
      const beforeInjection = line.substring(0, line.indexOf("test--"));
      const singleQuotes = (beforeInjection.match(/'/g) || []).length;

      // CREATE EXTENSION uses double quotes (safe)
      // But RAISE messages use single quotes (vulnerable)
      if (line.includes("RAISE")) {
        // Should be inside single quotes (odd number before)
        // EXPECTED TO FAIL: Currently unescaped
        expect(singleQuotes % 2).toBe(1);
      }
    }
  });

  test("should handle backslash escape sequences in extension name", async () => {
    const maliciousEntry = createMockEntry({ name: "test\\\\malicious" });

    const sql = await generateExtensionsInitScript([maliciousEntry]);

    expect(sql).toBeDefined();
    expect(sql.length).toBeGreaterThan(0);

    // PostgreSQL uses backslash as escape character in some contexts
    // Verify the SQL is syntactically valid

    // Check that status tracking table creation is present
    expect(sql).toContain("CREATE TABLE IF NOT EXISTS pg_aza_status");

    // Check for balanced quotes in lines with backslashes
    const linesWithBackslash = sql
      .split("\n")
      .filter((line) => line.includes("\\\\") && !line.trim().startsWith("--"));

    for (const line of linesWithBackslash) {
      // Count quotes - should be balanced (even number per line)
      const singleQuotes = (line.match(/'/g) || []).length;
      const doubleQuotes = (line.match(/"/g) || []).length;

      // Each line should have balanced quotes
      if (singleQuotes > 0) {
        expect(singleQuotes % 2).toBe(0);
      }
      if (doubleQuotes > 0) {
        expect(doubleQuotes % 2).toBe(0);
      }
    }
  });

  test("should handle time-delay injection attempts", async () => {
    const maliciousEntry = createMockEntry({ name: "test'; SELECT pg_sleep(10); --" });

    const sql = await generateExtensionsInitScript([maliciousEntry]);

    expect(sql).toBeDefined();
    expect(sql.length).toBeGreaterThan(0);

    // Verify time-delay injection is not executable
    const hasUnescapedSleep = containsUnescapedPattern(sql, "SELECT pg_sleep");

    // EXPECTED TO FAIL: Current implementation doesn't escape
    expect(hasUnescapedSleep).toBe(true); // Documents current vulnerable behavior
  });

  test("should handle dollar-quote injection attempts", async () => {
    const maliciousEntry = createMockEntry({ name: "test$$; DROP TABLE users; $$" });

    const sql = await generateExtensionsInitScript([maliciousEntry]);

    expect(sql).toBeDefined();
    expect(sql.length).toBeGreaterThan(0);

    // Dollar-quote could potentially break out of string contexts
    // Verify DROP is not executable
    const hasUnescapedDrop = containsUnescapedPattern(sql, "DROP TABLE users");

    // EXPECTED TO FAIL: Current implementation doesn't validate
    expect(hasUnescapedDrop).toBe(true); // Documents current vulnerable behavior

    // Verify the main DO block is intact
    expect(sql).toContain("DO $$");
    expect(sql).toContain("END;\n$$;");
  });

  test("should handle array bracket injection attempts", async () => {
    const maliciousEntry = createMockEntry({ name: "test']; DROP TABLE users; --" });

    const sql = await generateExtensionsInitScript([maliciousEntry]);

    expect(sql).toBeDefined();
    expect(sql.length).toBeGreaterThan(0);

    // Array brackets could potentially break out of ARRAY[] contexts
    const hasUnescapedDrop = containsUnescapedPattern(sql, "DROP TABLE users");

    // EXPECTED TO FAIL: Current implementation doesn't escape
    expect(hasUnescapedDrop).toBe(true); // Documents current vulnerable behavior
  });

  test("should properly quote extension names in CREATE EXTENSION", async () => {
    // This should work correctly - CREATE EXTENSION uses double quotes (identifier quoting)
    const entries = [
      createMockEntry({ name: "normal_ext" }),
      createMockEntry({ name: "test'; DROP TABLE users; --" }),
    ];

    const sql = await generateExtensionsInitScript(entries);

    // CREATE EXTENSION should use double quotes for identifiers
    // This provides proper escaping for SQL identifiers
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "normal_ext"');
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "test\'; DROP TABLE users; --"');

    // The double-quoted identifier is safe - PostgreSQL treats it as a literal name
    // The single quote inside double quotes is just a character, not SQL syntax
  });

  test("should document vulnerability in array literals and messages", async () => {
    const maliciousEntry = createMockEntry({ name: "test'; EXECUTE 'malicious'; --" });

    const sql = await generateExtensionsInitScript([maliciousEntry]);

    // This test documents the specific vulnerable locations:

    // 1. Array literal in DECLARE block (line 81)
    expect(sql).toContain("v_expected_exts TEXT[] := ARRAY[");

    // 2. Array append calls (lines 105, 108)
    // VULNERABILITY: If extension name contains single quote, it breaks SQL syntax
    // Should escape by doubling quotes: 'test''; EXECUTE ''malicious''; --'
    expect(sql).toContain("array_append");

    // 3. RAISE NOTICE/WARNING messages (lines 106, 111, 146)
    expect(sql).toMatch(/RAISE (NOTICE|WARNING)/);

    // All these locations need single-quote escaping
    // Expected fix: name.replace(/'/g, "''") before interpolation
  });
});

describe("generateExtensionsInitScript - pg_cron Filtering", () => {
  test("should filter pg_cron from extension list", async () => {
    const extensions = [
      createMockEntry({ name: "pg_stat_statements" }),
      createMockEntry({ name: "pg_cron" }),
      createMockEntry({ name: "postgis" }),
    ];

    const sql = await generateExtensionsInitScript(extensions);

    // pg_cron should not appear in CREATE EXTENSION statements
    // (it's handled by separate 01b-pg_cron.sh script)
    const createLines = sql
      .split("\n")
      .filter((line) => line.includes("CREATE EXTENSION IF NOT EXISTS"));

    const hasPgCronCreate = createLines.some((line) => line.includes("pg_cron"));
    expect(hasPgCronCreate).toBe(false);

    // Other extensions should be present
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "pg_stat_statements"');
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "postgis"');

    // Expected array should not include pg_cron
    expect(sql).toContain("ARRAY['pg_stat_statements', 'postgis']");
    expect(sql).not.toContain("'pg_cron'");
  });

  test("should mention pg_cron is handled separately in comments", async () => {
    const extensions = [
      createMockEntry({ name: "pg_stat_statements" }),
      createMockEntry({ name: "pg_cron" }),
    ];

    const sql = await generateExtensionsInitScript(extensions);

    // Should contain explanatory comments/messages about pg_cron
    expect(sql).toContain("pg_cron");
    expect(sql).toContain("01b-pg_cron.sh");

    // But should not create pg_cron extension
    const createLines = sql
      .split("\n")
      .filter((line) => line.includes("CREATE EXTENSION IF NOT EXISTS"));
    const hasPgCronCreate = createLines.some((line) => line.includes("pg_cron"));
    expect(hasPgCronCreate).toBe(false);
  });
});
