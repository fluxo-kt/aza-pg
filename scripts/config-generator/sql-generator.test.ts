#!/usr/bin/env bun
/**
 * Unit Test Suite for SQL Generator
 * Tests extension initialization SQL generation from manifest data
 *
 * Coverage:
 * - generateExtensionsInitScript creates valid SQL structure
 * - pg_aza_status table creation
 * - Extension creation with error handling
 * - Empty manifest handling
 * - Script structure validation
 *
 * Usage: bun test scripts/config-generator/sql-generator.test.ts
 */

import { describe, test, expect } from "bun:test";
import { generateExtensionsInitScript } from "./sql-generator";
import type { ManifestEntry } from "../extensions/manifest-data";

describe("generateExtensionsInitScript - Table Creation", () => {
  test("Creates pg_aza_status table", async () => {
    const extensions: ManifestEntry[] = [];
    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("CREATE TABLE IF NOT EXISTS pg_aza_status");
    expect(sql).toContain("id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY");
    expect(sql).toContain("init_timestamp TIMESTAMPTZ DEFAULT now()"); // Lowercase after formatting
    expect(sql).toContain("script_version TEXT NOT NULL");
    expect(sql).toContain("expected_extensions TEXT[] NOT NULL");
    expect(sql).toContain("created_extensions TEXT[] DEFAULT ARRAY[]::TEXT[]");
    expect(sql).toContain("failed_extensions TEXT[] DEFAULT ARRAY[]::TEXT[]");
    expect(sql).toContain("status TEXT NOT NULL");
  });

  test("Creates index on pg_aza_status", async () => {
    const extensions: ManifestEntry[] = [];
    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("CREATE INDEX IF NOT EXISTS idx_pg_aza_status_timestamp");
    expect(sql).toContain("ON pg_aza_status (init_timestamp DESC)"); // Space added by formatter
  });

  test("Status field has CHECK constraint", async () => {
    const extensions: ManifestEntry[] = [];
    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("CHECK (status IN ('in_progress', 'completed', 'failed', 'partial'))");
  });
});

describe("generateExtensionsInitScript - Extension Creation", () => {
  test("Single extension generates CREATE EXTENSION command", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "pgvector",
        kind: "extension",
        category: "ai",
        description: "Vector similarity search",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "pgvector"');
    expect(sql).toContain("v_created_exts := array_append(v_created_exts, 'pgvector')");
    expect(sql).toContain("RAISE NOTICE 'Created extension: pgvector'");
  });

  test("Multiple extensions all included in SQL", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "pgvector",
        kind: "extension",
        category: "ai",
        description: "Vector similarity search",
        source: { type: "builtin" },
      },
      {
        name: "pg_stat_statements",
        kind: "builtin",
        category: "observability",
        description: "Track statistics",
        source: { type: "builtin" },
      },
      {
        name: "postgis",
        kind: "extension",
        category: "geo",
        description: "Geographic objects",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "pgvector"');
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "pg_stat_statements"');
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "postgis"');
  });

  test("Extension displayName used in comments", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "pgvector",
        displayName: "pgVector - Vector Similarity",
        kind: "extension",
        category: "ai",
        description: "Vector similarity search",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("pgVector - Vector Similarity");
  });

  test("Extension category shown in comments", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "pgvector",
        kind: "extension",
        category: "machine-learning",
        description: "Vector similarity search",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("(machine-learning)");
  });
});

describe("generateExtensionsInitScript - Error Handling", () => {
  test("Each extension wrapped in BEGIN/EXCEPTION block", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "test_ext",
        kind: "extension",
        category: "test",
        description: "Test extension",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    // Check for exception handling structure
    expect(sql).toContain("BEGIN");
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "test_ext"');
    expect(sql).toContain("EXCEPTION WHEN OTHERS THEN");
    expect(sql).toContain("v_failed_exts := array_append(v_failed_exts, 'test_ext')");
    expect(sql).toContain("GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT");
    expect(sql).toContain("RAISE WARNING 'Failed to create extension test_ext: %'");
  });

  test("Status updated based on success/failure", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "test_ext",
        kind: "extension",
        category: "test",
        description: "Test extension",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("UPDATE pg_aza_status");
    expect(sql).toContain("created_extensions = v_created_exts");
    expect(sql).toContain("failed_extensions = v_failed_exts");
    expect(sql).toContain("WHEN array_length(v_failed_exts, 1) IS NULL THEN 'completed'");
    expect(sql).toContain("WHEN array_length(v_created_exts, 1) > 0 THEN 'partial'");
    expect(sql).toContain("ELSE 'failed'");
  });

  test("RAISE EXCEPTION on failures", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "test_ext",
        kind: "extension",
        category: "test",
        description: "Test extension",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("RAISE EXCEPTION 'Extension initialization FAILED");
    expect(sql).toContain("Required extensions not available: %");
    expect(sql).toContain("Successfully created: %'");
    expect(sql).toContain("USING HINT =");
  });
});

describe("generateExtensionsInitScript - Empty Manifest", () => {
  test("Empty array generates valid SQL", async () => {
    const extensions: ManifestEntry[] = [];
    const sql = await generateExtensionsInitScript(extensions);

    // Should still create table
    expect(sql).toContain("CREATE TABLE IF NOT EXISTS pg_aza_status");

    // Should handle empty case
    expect(sql).toContain("No extensions to enable");
    expect(sql).not.toContain("CREATE EXTENSION");
  });

  test("Empty manifest sets status to completed", async () => {
    const extensions: ManifestEntry[] = [];
    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("UPDATE pg_aza_status");
    expect(sql).toContain("SET status = 'completed'");
    expect(sql).toContain("No baseline extensions enabled");
  });
});

describe("generateExtensionsInitScript - DO Block Structure", () => {
  test("Uses DO $$ anonymous block", async () => {
    const extensions: ManifestEntry[] = [];
    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("DO $$");
    expect(sql).toContain("DECLARE");
    expect(sql).toContain("BEGIN");
    expect(sql).toContain("END;");
    expect(sql).toContain("$$;");
  });

  test("Declares necessary variables", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "test_ext",
        kind: "extension",
        category: "test",
        description: "Test extension",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("v_status_id INTEGER");
    expect(sql).toContain("v_expected_exts TEXT[]");
    expect(sql).toContain("v_created_exts TEXT[]");
    expect(sql).toContain("v_failed_exts TEXT[]");
    expect(sql).toContain("v_error_msg TEXT");
  });

  test("Records initialization start", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "test_ext",
        kind: "extension",
        category: "test",
        description: "Test extension",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("INSERT INTO pg_aza_status");
    expect(sql).toContain("script_version, expected_extensions, status, notes");
    expect(sql).toContain("'in_progress'");
    expect(sql).toContain("Baseline extension initialization started");
    expect(sql).toContain("RETURNING id INTO v_status_id");
  });
});

describe("generateExtensionsInitScript - Generation Metadata", () => {
  test("Includes generation comments", async () => {
    const extensions: ManifestEntry[] = [];
    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("PostgreSQL initialization");
    expect(sql).toContain("Generated by scripts/config-generator/generator.ts");
    expect(sql).toContain("DO NOT EDIT MANUALLY");
    expect(sql).toContain("Edit docker/postgres/extensions.manifest.json and regenerate");
  });

  test("Script version uses date format", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "test_ext",
        kind: "extension",
        category: "test",
        description: "Test extension",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    // Should contain a date in YYYY-MM-DD format
    const datePattern = /\d{4}-\d{2}-\d{2}/;
    expect(sql).toMatch(datePattern);
  });
});

describe("generateExtensionsInitScript - Expected Extensions Array", () => {
  test("Expected extensions array includes all extension names", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "ext1",
        kind: "extension",
        category: "test",
        description: "Test extension 1",
        source: { type: "builtin" },
      },
      {
        name: "ext2",
        kind: "extension",
        category: "test",
        description: "Test extension 2",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("v_expected_exts TEXT[] := ARRAY['ext1', 'ext2']");
  });

  test("Expected extensions list is properly formatted", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "single_ext",
        kind: "extension",
        category: "test",
        description: "Test extension",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("ARRAY['single_ext']");
  });
});

describe("generateExtensionsInitScript - Success Messages", () => {
  test("Success message lists all extensions", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "ext1",
        kind: "extension",
        category: "test",
        description: "Test extension 1",
        source: { type: "builtin" },
      },
      {
        name: "ext2",
        kind: "extension",
        category: "test",
        description: "Test extension 2",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("Baseline extensions enabled (ext1, ext2)");
  });

  test("Success message mentions additional extensions", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "test_ext",
        kind: "extension",
        category: "test",
        description: "Test extension",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("Additional extensions are available but disabled by default");
  });
});

describe("generateExtensionsInitScript - SQL Validity", () => {
  test("Generated SQL is non-empty", async () => {
    const extensions: ManifestEntry[] = [];
    const sql = await generateExtensionsInitScript(extensions);

    expect(sql.length).toBeGreaterThan(0);
  });

  test("SQL contains no obvious syntax errors", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "test_ext",
        kind: "extension",
        category: "test",
        description: "Test extension",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    // Check for balanced DO blocks
    const doCount = (sql.match(/DO \$\$/g) || []).length;
    const endCount = (sql.match(/\$\$;/g) || []).length;
    expect(doCount).toBe(endCount);

    // Check for balanced BEGIN/END (PL/pgSQL requires equal counts)
    const beginCount = (sql.match(/\bBEGIN\b/g) || []).length;
    const endKeywordCount = (sql.match(/\bEND;/g) || []).length;
    expect(beginCount).toBe(endKeywordCount);
  });

  test("Extension names are properly quoted", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "test_ext",
        kind: "extension",
        category: "test",
        description: "Test extension",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    // CREATE EXTENSION should use double quotes
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "test_ext"');

    // Array literals should use single quotes
    expect(sql).toContain("'test_ext'");
  });
});

describe("generateExtensionsInitScript - Real-World Scenarios", () => {
  test("Production-like manifest with multiple extensions", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "pg_stat_statements",
        displayName: "pg_stat_statements",
        kind: "builtin",
        category: "observability",
        description: "Track planning and execution statistics",
        source: { type: "builtin" },
      },
      {
        name: "pgvector",
        displayName: "pgVector",
        kind: "extension",
        category: "ai",
        description: "Vector similarity search",
        source: {
          type: "git",
          repository: "https://github.com/pgvector/pgvector.git",
          tag: "v0.7.0",
        },
      },
      {
        name: "postgis",
        kind: "extension",
        category: "geo",
        description: "Geographic objects",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    // All extensions should be present
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "pg_stat_statements"');
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "pgvector"');
    expect(sql).toContain('CREATE EXTENSION IF NOT EXISTS "postgis"');

    // Should have proper structure
    expect(sql).toContain("CREATE TABLE IF NOT EXISTS pg_aza_status");
    expect(sql).toContain("DO $$");
    expect(sql).toContain("DECLARE");
    expect(sql).toContain(
      "v_expected_exts TEXT[] := ARRAY['pg_stat_statements', 'pgvector', 'postgis']"
    );
  });

  test("Extensions without displayName use name", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "simple_ext",
        kind: "extension",
        category: "test",
        description: "Test extension",
        source: { type: "builtin" },
      },
    ];

    const sql = await generateExtensionsInitScript(extensions);

    // Name should appear in comment (category is always present)
    expect(sql).toContain("simple_ext (test)");
  });

  test("Extension without category defaults to misc", async () => {
    const extensions: ManifestEntry[] = [
      {
        name: "test_ext",
        kind: "extension",
        // No category specified
        description: "Test extension",
        source: { type: "builtin" },
      } as any,
    ];

    const sql = await generateExtensionsInitScript(extensions);

    expect(sql).toContain("(misc)");
  });
});
