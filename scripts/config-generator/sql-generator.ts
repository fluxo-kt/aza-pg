/**
 * SQL Generator
 * Generates PostgreSQL initialization SQL scripts from manifest data
 */

import { format } from "sql-formatter";
import type { ManifestEntry } from "../extensions/manifest-data";

/**
 * Generate 01-extensions.sql initialization script with state tracking
 * Creates SQL that:
 * 1. Creates status tracking table for auditability
 * 2. Records expected extensions before creation
 * 3. Attempts to create each extension with error handling
 * 4. Records actual results (success/failure) for healthcheck verification
 *
 * This eliminates hardcoded duplication between init script and healthcheck
 * by providing a database-native single source of truth.
 *
 * @param extensionsToEnable - Array of manifest entries for extensions to enable
 * @returns SQL script content as string
 */
export async function generateExtensionsInitScript(
  extensionsToEnable: ManifestEntry[]
): Promise<string> {
  const lines: string[] = [];

  lines.push("-- PostgreSQL initialization: enable baseline extensions with state tracking");
  lines.push("-- Runs automatically on first cluster start.");
  lines.push("-- Generated by scripts/config-generator/generator.ts from extensions.manifest.json");
  lines.push("--");
  lines.push("-- DO NOT EDIT MANUALLY - Changes will be overwritten");
  lines.push("-- Edit docker/postgres/extensions.manifest.json and regenerate");
  lines.push("");

  // Create status tracking infrastructure
  lines.push("-- Create initialization status tracking table");
  lines.push("-- This table serves as the contract between initialization and healthcheck");
  lines.push("-- Healthcheck queries this table instead of hardcoding extension lists");
  lines.push("CREATE TABLE IF NOT EXISTS pg_aza_status (");
  lines.push("    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,");
  lines.push("    init_timestamp TIMESTAMPTZ DEFAULT NOW(),");
  lines.push("    script_version TEXT NOT NULL,");
  lines.push("    expected_extensions TEXT[] NOT NULL,");
  lines.push("    created_extensions TEXT[] DEFAULT ARRAY[]::TEXT[],");
  lines.push("    failed_extensions TEXT[] DEFAULT ARRAY[]::TEXT[],");
  lines.push(
    "    status TEXT NOT NULL CHECK (status IN ('in_progress', 'completed', 'failed', 'partial')),"
  );
  lines.push("    error_details TEXT,");
  lines.push("    notes TEXT");
  lines.push(");");
  lines.push("");

  // Create index for efficient healthcheck queries
  lines.push("-- Index for efficient healthcheck queries (latest status)");
  lines.push(
    "CREATE INDEX IF NOT EXISTS idx_pg_aza_status_timestamp ON pg_aza_status(init_timestamp DESC);"
  );
  lines.push("");

  const extensionNames = extensionsToEnable.map((e) => e.name);
  const scriptVersion = new Date().toISOString().split("T")[0]; // YYYY-MM-DD format

  // Start initialization tracking
  lines.push("DO $$");
  lines.push("DECLARE");
  lines.push("    v_status_id INTEGER;");
  lines.push(
    "    v_expected_exts TEXT[] := ARRAY[" + extensionNames.map((n) => `'${n}'`).join(", ") + "];"
  );
  lines.push("    v_created_exts TEXT[] := ARRAY[]::TEXT[];");
  lines.push("    v_failed_exts TEXT[] := ARRAY[]::TEXT[];");
  lines.push("    v_error_msg TEXT;");
  lines.push("BEGIN");
  lines.push("    -- Record initialization start");
  lines.push("    INSERT INTO pg_aza_status (script_version, expected_extensions, status, notes)");
  lines.push(
    `    VALUES ('${scriptVersion}', v_expected_exts, 'in_progress', 'Baseline extension initialization started')`
  );
  lines.push("    RETURNING id INTO v_status_id;");
  lines.push("");

  if (extensionsToEnable.length > 0) {
    lines.push("    -- Attempt to create each extension with error handling");
    for (const entry of extensionsToEnable) {
      const displayName = entry.displayName ?? entry.name;
      const category = entry.category ?? "misc";
      lines.push("");
      lines.push(`    -- ${displayName} (${category})`);
      lines.push("    BEGIN");
      lines.push(`        CREATE EXTENSION IF NOT EXISTS "${entry.name}";`);
      lines.push(`        v_created_exts := array_append(v_created_exts, '${entry.name}');`);
      lines.push(`        RAISE NOTICE 'Created extension: ${entry.name}';`);
      lines.push("    EXCEPTION WHEN OTHERS THEN");
      lines.push(`        v_failed_exts := array_append(v_failed_exts, '${entry.name}');`);
      lines.push("        GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;");
      lines.push(
        `        RAISE WARNING 'Failed to create extension ${entry.name}: %', v_error_msg;`
      );
      lines.push("    END;");
    }
    lines.push("");

    // Update final status
    lines.push("    -- Update initialization status based on results");
    lines.push("    UPDATE pg_aza_status");
    lines.push("    SET");
    lines.push("        created_extensions = v_created_exts,");
    lines.push("        failed_extensions = v_failed_exts,");
    lines.push("        status = CASE");
    lines.push("            WHEN array_length(v_failed_exts, 1) IS NULL THEN 'completed'");
    lines.push("            WHEN array_length(v_created_exts, 1) > 0 THEN 'partial'");
    lines.push("            ELSE 'failed'");
    lines.push("        END,");
    lines.push("        notes = CASE");
    lines.push("            WHEN array_length(v_failed_exts, 1) IS NULL THEN");
    lines.push(
      `                'All ${extensionsToEnable.length} baseline extensions created successfully'`
    );
    lines.push("            ELSE");
    lines.push(
      "                'Initialization completed with ' || array_length(v_failed_exts, 1)::TEXT || ' failure(s)'"
    );
    lines.push("        END");
    lines.push("    WHERE id = v_status_id;");
    lines.push("");

    // Final notice
    lines.push("    -- Log final status");
    lines.push("    IF array_length(v_failed_exts, 1) IS NULL THEN");
    lines.push(
      `        RAISE NOTICE 'Baseline extensions enabled (${extensionNames.join(", ")}). Additional extensions are available but disabled by default.';`
    );
    lines.push("    ELSE");
    lines.push(
      "        RAISE WARNING 'Initialization completed with failures. Created: %, Failed: %', v_created_exts, v_failed_exts;"
    );
    lines.push("    END IF;");
  } else {
    lines.push("    -- No extensions to enable");
    lines.push("    UPDATE pg_aza_status");
    lines.push("    SET status = 'completed',");
    lines.push(
      "        notes = 'No baseline extensions enabled. All extensions available but must be created manually.'"
    );
    lines.push("    WHERE id = v_status_id;");
    lines.push("");
    lines.push(
      "    RAISE NOTICE 'No baseline extensions enabled. All extensions available but must be created manually.';"
    );
  }

  lines.push("END;");
  lines.push("$$;");
  lines.push("");

  const rawSql = lines.join("\n");

  // Format the generated SQL using sql-formatter
  try {
    const configPath = new URL("../../.sql-formatter.json", import.meta.url);
    const configFile = Bun.file(configPath);
    const config = await configFile.json();
    return format(rawSql, config);
  } catch (error) {
    // If formatting fails, return unformatted SQL (graceful degradation)
    console.warn("SQL formatting failed, returning unformatted SQL:", error);
    return rawSql;
  }
}
