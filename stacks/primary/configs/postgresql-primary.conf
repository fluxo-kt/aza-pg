# PostgreSQL 18 Primary Server Configuration
# Optimized for 2GB RAM with replication

listen_addresses = '*'
port = 5432

# PostgreSQL 18 Asynchronous I/O (2-3x performance improvement)
io_method = 'worker'
io_combine_limit = 128
io_max_combine_limit = 256

max_connections = 100
superuser_reserved_connections = 3

# TLS/SSL Configuration (uncomment to enable)
# Generate certs: scripts/tools/generate-ssl-certs.sh stacks/primary/certs
# Mount in compose.yml: - ./certs:/etc/postgresql/certs:ro
# ssl = on
# ssl_cert_file = '/etc/postgresql/certs/server.crt'
# ssl_key_file = '/etc/postgresql/certs/server.key'
# ssl_ca_file = '/etc/postgresql/certs/ca.crt'
# ssl_min_protocol_version = 'TLSv1.3'  # PostgreSQL 18 supports TLS 1.3
# ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL'
# ssl_prefer_server_ciphers = on
# ssl_tls13_ciphers = 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256'  # PostgreSQL 18

shared_buffers = 256MB
effective_cache_size = 768MB
maintenance_work_mem = 64MB
work_mem = 4MB
temp_buffers = 8MB

bgwriter_delay = 200ms
bgwriter_lru_maxpages = 100
bgwriter_lru_multiplier = 2.0

wal_level = replica
fsync = on
wal_sync_method = fdatasync
full_page_writes = on
wal_compression = lz4  # Faster than pglz, better than 'on' (which uses pglz)

# WAL Archiving (disabled by default - not required for streaming replication)
# To enable: uncomment below, create /backup/wal directory, mount as volume
# archive_mode = on
# archive_command = 'test ! -f /backup/wal/%f && cp %p /backup/wal/%f'
# archive_timeout = 300

wal_buffers = 16MB
max_wal_size = 4GB
min_wal_size = 1GB
checkpoint_completion_target = 0.9

max_wal_senders = 3
max_replication_slots = 2
wal_keep_size = 1GB
max_slot_wal_keep_size = 10GB
idle_replication_slot_timeout = '48h'  # PostgreSQL 18: Prevent WAL bloat from abandoned slots
hot_standby = on
hot_standby_feedback = on
# Use 'local' for replication without waiting for remote confirmation
# Use 'on' for full durability (wait for remote replicas)
# Use 'remote_write' for balance (wait for remote write, not fsync)
synchronous_commit = local

random_page_cost = 1.1
effective_io_concurrency = 200
default_statistics_target = 100

seq_page_cost = 1.0
cpu_tuple_cost = 0.01
cpu_index_tuple_cost = 0.005
cpu_operator_cost = 0.0025

max_parallel_workers_per_gather = 2
max_parallel_workers = 4
max_worker_processes = 4

autovacuum = on
autovacuum_max_workers = 3
autovacuum_naptime = 1min
autovacuum_vacuum_threshold = 50
autovacuum_analyze_threshold = 50
autovacuum_vacuum_scale_factor = 0.1
autovacuum_analyze_scale_factor = 0.05
autovacuum_vacuum_cost_delay = 2ms
autovacuum_vacuum_cost_limit = 2000  # SSD-friendly

datestyle = 'iso, mdy'
timezone = 'UTC'
lc_messages = 'en_US.utf8'
lc_monetary = 'en_US.utf8'
lc_numeric = 'en_US.utf8'
lc_time = 'en_US.utf8'
default_text_search_config = 'pg_catalog.english'

log_destination = 'stderr'
logging_collector = off
log_min_duration_statement = 1000
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
log_lock_waits = on
log_statement = 'ddl'
log_temp_files = 0

shared_preload_libraries = 'pg_stat_statements,pg_cron,pgaudit,auto_explain'

pg_stat_statements.max = 10000
pg_stat_statements.track = all

auto_explain.log_min_duration = '3s'
auto_explain.log_analyze = true
auto_explain.log_buffers = true
auto_explain.log_timing = false
auto_explain.log_nested_statements = true

cron.database_name = 'postgres'
cron.use_background_workers = on

pgaudit.log = 'ddl'
pgaudit.log_catalog = off
pgaudit.log_parameter = on
