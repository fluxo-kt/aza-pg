-- vectorscale Extension Basic Functionality Test
-- Tests AI/ML vector operations (depends on pgvector)
-- vectorscale requires pgvector
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS vectorscale;
-- Test 1: Verify extensions loaded
SELECT extname, extversion FROM pg_extension
WHERE extname IN ('vector', 'vectorscale')
ORDER BY extname;
extname | extversion
-------------+------------
vector | 0.8.1
vectorscale | 0.9.0
(2 rows)
-- Test 2: Verify vectorscale schema exists
SELECT count(*) > 0 AS has_vectorscale_schema
FROM pg_namespace
WHERE nspname = 'vectorscale';
has_vectorscale_schema
------------------------
f
(1 row)
-- Test 3: Verify vectorscale functions exist
SELECT count(*) > 0 AS has_functions
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname = 'vectorscale';
has_functions
---------------
f
(1 row)
-- Test 4: Create test table with vector column
CREATE TABLE test_vectors (
id SERIAL PRIMARY KEY,
embedding vector(3),
metadata TEXT
);
-- Test 5: Insert test vectors
INSERT INTO test_vectors (embedding, metadata) VALUES
('[1,2,3]'::vector, 'first'),
('[4,5,6]'::vector, 'second'),
('[7,8,9]'::vector, 'third'),
('[2,3,4]'::vector, 'fourth'),
('[5,6,7]'::vector, 'fifth');
-- Test 6: Test cosine similarity search (pgvector operator)
-- Using <=> for cosine distance (1 - cosine similarity)
SELECT id, metadata, embedding <=> '[1,2,3]'::vector AS cosine_distance
FROM test_vectors
ORDER BY cosine_distance
LIMIT 3;
id | metadata | cosine_distance
----+----------+----------------------
1 | first | 0
4 | fourth | 0.007416666029069763
2 | second | 0.025368153802923787
(3 rows)
-- Test 7: Test L2 distance (Euclidean)
SELECT id, metadata, embedding <-> '[1,2,3]'::vector AS l2_distance
FROM test_vectors
ORDER BY l2_distance
LIMIT 3;
id | metadata | l2_distance
----+----------+--------------------
1 | first | 0
4 | fourth | 1.7320508075688772
2 | second | 5.196152422706632
(3 rows)
-- Test 8: Test inner product (negative for max-heap)
SELECT id, metadata, embedding <#> '[1,2,3]'::vector AS neg_inner_product
FROM test_vectors
ORDER BY neg_inner_product
LIMIT 3;
id | metadata | neg_inner_product
----+----------+-------------------
3 | third | -50
5 | fifth | -38
2 | second | -32
(3 rows)
-- Test 9: Create StreamingDiskANN index (vectorscale-specific)
-- This is the key feature of vectorscale - optimized indexing for large-scale vectors
CREATE INDEX ON test_vectors USING diskann (embedding);
NOTICE:  Starting index build with num_neighbors=-1, search_list_size=100, max_alpha=1.2, storage_layout=SbqCompression.
NOTICE:  Indexed 5 tuples
-- Test 10: Verify index created
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'test_vectors'
AND indexdef LIKE '%diskann%';
indexname | indexdef
----------------------------+------------------------------------------------------------------------------------------
test_vectors_embedding_idx | CREATE INDEX test_vectors_embedding_idx ON public.test_vectors USING diskann (embedding)
(1 row)
-- Test 11: Test query with index (should use DiskANN)
-- Same cosine similarity query, but now with index
SELECT id, metadata
FROM test_vectors
ORDER BY embedding <=> '[1,2,3]'::vector
LIMIT 2;
id | metadata
----+----------
1 | first
4 | fourth
(2 rows)
-- Test 12: Vector operations work correctly
SELECT
'[1,0,0]'::vector <=> '[1,0,0]'::vector AS identical_vectors,
'[1,0,0]'::vector <=> '[0,1,0]'::vector AS orthogonal_vectors;
identical_vectors | orthogonal_vectors
-------------------+--------------------
0 | 1
(1 row)
-- Cleanup
DROP TABLE test_vectors;
-- Test 13: Verify cleanup
SELECT count(*) AS remaining_test_tables
FROM pg_tables
WHERE tablename = 'test_vectors';
remaining_test_tables
-----------------------
0
(1 row)
